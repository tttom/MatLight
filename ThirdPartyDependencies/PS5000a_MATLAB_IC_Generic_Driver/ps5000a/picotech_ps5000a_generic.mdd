<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>picotech_ps5000a_generic.mdd</DriverName>
   <DriverType>MATLAB generic</DriverType>
   <InstrumentType>Oscilloscope</InstrumentType>
   <InstrumentManufacturer>Pico Technology Ltd.</InstrumentManufacturer>
   <InstrumentModel>PicoScope 5000 Series</InstrumentModel>
   <InstrumentVersion>1.1.9</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Copyright (C) Pico Technology Ltd. 2013. 
% You may copy and distribute this file as long as it remains unmodified. 
    
    fprintf('\nCopyright (C) Pico Technology Ltd. 2013\n');
    fprintf('\n');
    fprintf('PicoScope 5000 Series MATLAB Instrument Driver\n');
    fprintf('\n');

    % Only load library once 
    if(libisloaded('ps5000a'))
       
        % Do nothing
        
    else
        
        loadlibrary('ps5000a.dll','ps5000aMFile');
        
    end
    
    % Check if the library still has not loaded
    if ~libisloaded('ps5000a')
        
        error('Library ps5000a.dll or ps5000aMFile not found - please check the MATLAB Path.') 
        
    end

    % Only load library once 
    if(libisloaded('ps5000aWrap'))

        % Do nothing
        
    else
        
        loadlibrary('ps5000aWrap.dll', 'ps5000aWrapMFile');
        
    end
    
    %check if the library still has not loaded
    if ~libisloaded('ps5000aWrap')
        
        error('Library ps5000aWrap.dll or ps5000aWrapMFile not found - please check the MATLAB Path.') 
        
    end
    
    % Confirm data files have been loaded
    if (exist('PicoConstants.m', 'file') == 0)
    
        error('File PicoConstants.m not found - please ensure that the location of this file is added to the MATLAB Path.')
    
    end

    if (exist('PS5000aConstants.m', 'file') == 0)
    
        error('File PS5000aConstants.m not found - please ensure that the location of this file is added to the MATLAB Path.')
    
    end

    if(isstruct(evalin('base', 'ps5000aEnuminfo')) &amp;&amp; isstruct(evalin('base', 'ps5000aStructs')))
    
        % Do nothing - structures have been loaded
    
    else

        error('Failed to load enumerations and/or structures from ps5000aMFile');
    
    end
    
    % Enumerate units - only displayed if driver is being used via command
    % line
    
    count = int16(0);
    serials = blanks(100);
    serialLth = int16(100);
    
    [status, count, serials, serialLth] = calllib('ps5000a', ...
        'ps5000aEnumerateUnits',  count, serials, serialLth);
    
    if(status == PicoStatus.PICO_OK)
        
        fprintf('Number of units found: %d\n\nSerial number(s): %s\n', count, serials);
        
    elseif(status == PicoStatus.PICO_NOT_FOUND)
        
        error('No units found.');
        
    else
        
        error('Status code: %d\n', status);
        
    end
    </Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Copyright (C) Pico Technology Ltd. 2013. 
% You may copy and distribute this file as long as it remains unmodified.

    disp('Opening PicoScope 5000 Series device...');

    % Structure to hold status values while connecting to the device.
    % Only output when the driver is called using command line or script.
    connect_status = [];

    % Temporary variable to store handle value
    unit_handle = 0;
    
    % PICO_OK status value (0)
    pico_ok = PicoStatus.PICO_OK;

    % Obtain the serial input
    serial_num = get(obj, 'RsrcName');

    % Determine if serial number is specified or null
    if length(serial_num) &gt; 0

        unit_serial = serial_num;

    else

        unit_serial = [];

    end
    
    % Default resolution set to 8-bits
    resolution_8bit = evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_8BIT');
    obj.UserData.resolution = 8;

    % Open the unit
    [connect_status.open_unit, obj.UserData.unitHandle, obj.UserData.unitSerial] = ...
        calllib('ps5000a', 'ps5000aOpenUnit', unit_handle, unit_serial, resolution_8bit);

    % Check Power Settings

    power_status = 0;

    % Power supply not connected
    if(connect_status.open_unit == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED) 

        power_status = invoke(obj, 'ps5000aChangePowerSource', ...
            connect_status.open_unit);
    
    end

    % Set handle and serial 
    % Unit connected if 0 or power supply not connected
    if(connect_status.open_unit == pico_ok || power_status == pico_ok)

        % Display object information
        obj
        
        unit_handle = obj.UserData.unitHandle;
        set(obj, 'unitHandle', obj.UserData.unitHandle);
        %fprintf('Handle: %d\n', unit_handle);

        info_line = '           ';
        req_size = 15;

        [connect_status.unit_serial, unit_serial, req_size]  = calllib('ps5000a', ...
                'ps5000aGetUnitInfo', unit_handle, info_line, ... 
                length(info_line), req_size, PicoStatus.PICO_BATCH_AND_SERIAL);

        %disp('Setting device serial number...');
        set(obj, 'unitSerial', unit_serial);
        %fprintf('Batch/Serial number: %s\n', unit_serial);

        % Set variant and channel count information
        %disp('Setting variant and channel count...')

        info_line_v = blanks(15);
        req_size_v = 15;
        
        [connect_status.unit_variant, variant, req_size_v]  = calllib('ps5000a', ...
                'ps5000aGetUnitInfo', unit_handle, info_line_v, ... 
                length(info_line_v), req_size_v, PicoStatus.PICO_VARIANT_INFO);

        set(obj, 'InstrumentModel', variant);
        %fprintf('InstrumentModel: %s\n', get(obj, 'InstrumentModel'));

        % Set device parameters
        invoke(obj, 'resetDevice');
        
        % Display unit information to user if not using TMTool
        fprintf('\n');
        fprintf('Connected to PicoScope 5000 Series device:-\n\n');
        fprintf('     Instrument Model: %s\n', get(obj, 'InstrumentModel'));
        fprintf('  Batch/Serial Number: %s\n', unit_serial);
        fprintf('    Analogue Channels: %d\n', get(obj, 'channelCount'));
        fprintf('           Resolution: %d bits\n', get(obj, 'resolution'));
        
        %digital_ports = get(obj, 'digitalPorts');
        
        %if(digital_ports &gt; 0)
           
        %    fprintf('     Digital Channels: %d\n', digital_ports * 8);
            
        %end
            
        % Bandwidth information
        bandwidth_hz = get(obj, 'bandwidth');
        
        if(bandwidth_hz &gt; 0 &amp;&amp; bandwidth_hz &lt; 1e9)
            
           fprintf('            Bandwidth: %d MHz\n', (bandwidth_hz/1e6));
           
        elseif(bandwith_hz &gt;= 1e9)
            
           fprintf('            Bandwidth: %d GHz\n', (bandwidth_hz/1e9));
           
        else
            
            % Do nothing
            
        end
        
        
        fprintf('        Buffer memory: %d MS\n', get(obj, 'bufferMemory')/pow2(20));
        
        % Sampling rate information
        max_sampling_rate = get(obj, 'maxSamplingRate');
        
        if(max_sampling_rate &gt; 0 &amp;&amp; max_sampling_rate &lt; 1e9)
            
            fprintf('Maximum sampling rate: %d MS/s\n', max_sampling_rate/1e6);
            
        elseif(max_sampling_rate &gt;= 1e9)
           
            fprintf('Maximum sampling rate: %d GS/s\n', max_sampling_rate/1e9);
            
        else
            
            % Do nothing
            
        end
        
        clear bandwidth_hz;
        clear max_sampling_rate;

        % Output the signal generator type
        sig_gen_type = 'None';
    
        switch (get(obj, 'sigGenType'))

            case PicoConstants.SIG_GEN_FUNCT_GEN

                sig_gen_type = 'Function Generator';

            case PicoConstants.SIG_GEN_AWG

                sig_gen_type = 'Arbitrary Waveform Generator';

            otherwise

                % Already set to none

        end
    
        fprintf('Signal Generator Type: %s\n\n', sig_gen_type);

        % Output if power supply connected.
        if(get(obj, 'channelCount') == PicoConstants.QUAD_SCOPE)

            current_power_status = calllib('ps5000a', 'ps5000aCurrentPowerSource', ...
                                        obj.UserData.unitHandle);

            if(current_power_status == evalin('base', 'PicoStatus.PICO_POWER_SUPPLY_CONNECTED'))

                fprintf('Power Supply connected: True\n');

            else

                fprintf('Power Supply connected: False\n');

            end

        end

        % DEBUG - Display status (will not display in TMTOOL)
        % connect_status

    elseif(connect_status.open_unit == PicoStatus.PICO_NOT_FOUND)

        error('No unit found, please check connections.');

    else

        error('Status code: %d\n', connect_status.open_unit);

    end</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

    unit_handle = get(obj, 'unitHandle');

    if (isempty(unit_handle)) 
        % If no unithandle, return without doing anything
        return;
    end

    % Disconnect Code:

    disconnect_status = calllib('ps5000a', 'ps5000aCloseUnit', unit_handle);

    fprintf('Close unit status: %d\n', disconnect_status);

    unloadlibrary('ps5000aWrap');
    unloadlibrary('ps5000a');

    if(disconnect_status == PicoStatus.PICO_OK)

        disp('Unit closed successfully.');

    else

        error('Unit not closed.');

    end
    
    if (~libisloaded('ps5000a') &amp;&amp; ~libisloaded('ps5000aWrap'))
    
        disp('Libraries unloaded successfully.');

    else

        error('Libraries not unloaded successfully.');
    
    end</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoStop</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If autoStop doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'autoStop') )
        obj.UserData.autoStop = 0;
    else
        propertyValue = obj.UserData.autoStop;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.autoStop = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>A flag to specify if streaming data collection should stop when all of maxSamples have been taken.

This flag should be set to 0 or 1.</Description>
            </Property>
            <Property>
               <Name>awgBufferSize</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If awgBufferSize doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'awgBufferSize') )
        obj.UserData.awgBufferSize = 0;
    else
        propertyValue = obj.UserData.awgBufferSize;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.awgBufferSize = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The size of the arbitrary waveform buffer on the device, in samples. Applies only to the 'B' and MSO variants in the PicoScope 3000 Series range.

</Description>
            </Property>
            <Property>
               <Name>bandwidth</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If bandwidth doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'bandwidth') )
        obj.UserData.bandwidth = 0;
    end
    
    propertyValue = obj.UserData.bandwidth;
    </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.bandwidth = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>bandwidth represents the maximum bandwidth (3dB cut-off point) of the oscilloscope in Hertz.</Description>
            </Property>
            <Property>
               <Name>bufferMemory</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If bufferMemory doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'bufferMemory') )
        obj.UserData.bufferMemory = 0;
    else
        propertyValue = obj.UserData.bufferMemory;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.bufferMemory = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>4194304</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Defines the size of the memory buffer on the device (in samples).</Description>
            </Property>
            <Property>
               <Name>channelCount</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If channelCount doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'channelCount') )
        obj.UserData.channelCount = [ ];
    end

    propertyValue = obj.UserData.channelCount;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.channelCount = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>2</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of analogue input channels on the device.</Description>
            </Property>
            <Property>
               <Name>channelSettings</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If channelSettings doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'channelSettings') )
        
        obj.UserData.channelSettings = [ ];
    else
        
        propertyValue = obj.UserData.channelSettings;
    end

    %propertyValue = obj.UserData.channelSettings;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.channelSettings = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Object</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>A matrix containing the channel settings for analogue channels.

This will consist of a 4 x 4 matrix.

The row number will correspond to the channel:

1 - Channel A
2 - Channel B
3 - Channel C
4 - Channel D

Each row will contain the following elements corresponding to:

enabled - set to 0 (off) or 1 (on).
dc - set DC/AC coupling. 
range - an enumeration representing the voltage range.
analogueOffset - the offset on the channel.

</Description>
            </Property>
            <Property>
               <Name>dacFrequency</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If dacFrequency doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'dacFrequency') )
        obj.UserData.dacFrequency = [ ];
    end
    
    propertyValue = obj.UserData.dacFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.dacFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>20000000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>dacFrequency is the update frequency of the Arbitrary Waveform Generator.</Description>
            </Property>
            <Property>
               <Name>digitalPorts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If digitalPorts doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'digitalPorts') )
        obj.UserData.digitalPorts = [ ];
    end
    
    propertyValue = obj.UserData.digitalPorts;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.digitalPorts = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of digital ports on the device (MSO Devices only).</Description>
            </Property>
            <Property>
               <Name>digitalPortSettings</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If digitalPortSettings doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'digitalPortSettings') )
        obj.UserData.digitalPortSettings = [ ];
    end

    propertyValue = obj.UserData.digitalPortSettings;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.digitalPortSettings = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>A structure containing the channel settings for digital ports (MSO Only).</Description>
            </Property>
            <Property>
               <Name>firstRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If firstRange doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'firstRange') )
        obj.UserData.firstRange = [ ];
    else
        propertyValue = obj.UserData.firstRange;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.firstRange = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enumeration corresponding to the lowest voltage range supported by the device.</Description>
            </Property>
            <Property>
               <Name>hasHardwareEts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If hasHardwareEts doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'hasHardwareEts') )
        obj.UserData.hasHardwareEts = [ ];
    end
    
    propertyValue = obj.UserData.hasHardwareEts;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.hasHardwareEts = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Indicates if the device has hardware-based Equivalent Time Sampling.</Description>
            </Property>
            <Property>
               <Name>lastRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If lastRange doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'lastRange') )
        obj.UserData.lastRange = [ ];
    else
        propertyValue = obj.UserData.lastRange;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.lastRange = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>10</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enumeration corresponding to highest voltage range supported by device.</Description>
            </Property>
            <Property>
               <Name>maxADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If maxADCValue doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'maxADCValue') )
        obj.UserData.maxADCValue = 0;
    else
        propertyValue = obj.UserData.maxADCValue;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.maxADCValue = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>32512</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The maximum ADC count value for the device.</Description>
            </Property>
            <Property>
               <Name>maxSamplingRate</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If maxSamplingRate doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'maxSamplingRate') )
        obj.UserData.maxSamplingRate = [ ];
    end
    
    propertyValue = obj.UserData.maxSamplingRate;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.UserData.maxSamplingRate;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The maximum single shot sampling rate for the device (samples per second).</Description>
            </Property>
            <Property>
               <Name>minADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If minADCValue doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'minADCValue') )
        obj.UserData.minADCValue = 0;
    else
        propertyValue = obj.UserData.minADCValue;
    end
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.minADCValue = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>-32512</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The minimum ADC count value for the device.</Description>
            </Property>
            <Property>
               <Name>numPostTriggerSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If numPostTriggerSamples doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'numPostTriggerSamples') )
        obj.UserData.numPostTriggerSamples = [ ];
    end
    
    propertyValue = obj.UserData.numPostTriggerSamples;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.numPostTriggerSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to be taken after a trigger event.

If no trigger event has been set then this specifies the maximum number of samples to be taken. If a trigger
condition has been set, this specifies the number of samples to be taken after a trigger has fired, and the number of samples to be
collected is then: -

noOfPreTriggerSamples + noOfPostTriggerSamples

When used in Streaming mode, this is the maximum number of raw samples after a trigger event for each enabled channel.</Description>
            </Property>
            <Property>
               <Name>numPreTriggerSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If numPreTriggerSamples doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'numPreTriggerSamples') )
        obj.UserData.numPreTriggerSamples = [ ];
    end
    
    propertyValue = obj.UserData.numPreTriggerSamples;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.numPreTriggerSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to return before the trigger event.

If no trigger has been set then this argument is ignored and noOfPostTriggerSamples specifies the maximum number of samples to collect.

When used in Streaming mode, this is the maximum number of raw samples before the trigger event for each enabled channel.
</Description>
            </Property>
            <Property>
               <Name>resolution</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If resolution doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'resolution') )
        obj.UserData.resolution = [ ];

    else

         propertyValue = obj.UserData.resolution;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.resolution = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>8.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The resolution of the device, in bits.</Description>
            </Property>
            <Property>
               <Name>sigGenType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If sigGenType doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'sigGenType') )
        obj.UserData.sigGenType = [ ];

    else

         propertyValue = obj.UserData.sigGenType;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.sigGenType = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The type of Signal Generator on the device:

0 - None
1 - Function Generator
2 - Arbitrary Waveform Generator</Description>
            </Property>
            <Property>
               <Name>startFrequency</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If startFrequency doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'startFrequency') )
        obj.UserData.startFrequency = [ ];
    end
    
    propertyValue = obj.UserData.startFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.startFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>1000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency that the signal generator will initially produce (Hertz).</Description>
            </Property>
            <Property>
               <Name>stopFrequency</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If stopFrequency doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'stopFrequency') )
        obj.UserData.stopFrequency = [ ];
    end
    
    propertyValue = obj.UserData.stopFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.stopFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency at which the sweep reverses direction or returns to the initial frequency (Hertz).

To output a signal with constant frequency, ensure that stopFrequency is equal to startFrequency.</Description>
            </Property>
            <Property>
               <Name>streamingInterval</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If streamingInterval doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'streamingInterval') )
        obj.UserData.streamingInterval = [ ];
    end
    
    propertyValue = obj.UserData.streamingInterval;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.streamingInterval = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The requested time interval between samples (in seconds) when capturing data in streaming mode.</Description>
            </Property>
            <Property>
               <Name>timebase</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If timebase doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'timebase') )
        obj.UserData.timebase = 1;
    else
        propertyValue = obj.UserData.timebase;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.timebase = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>65</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The timebase used for the scope when capturing data in Block mode - please refer to the Programmer's Guide for the formulae to calculate the timebase index based on the interval.</Description>
            </Property>
            <Property>
               <Name>unitHandle</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If UserData.unitHandle doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'unitHandle') )
        obj.UserData.unitHandle = [ ];
    else
        propertyValue = obj.UserData.unitHandle;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.unitHandle = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The handle assigned by the underlying driver for the device.</Description>
            </Property>
            <Property>
               <Name>unitSerial</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % If UserData.unitserial doesn't exist, create it.
    if ( ~isfield(obj.UserData, 'unitSerial') )
        obj.UserData.unitSerial = [ ];
    else
        propertyValue = obj.UserData.unitSerial;
    end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.UserData.unitSerial = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>The device batch/serial number.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>autoStopped</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function autoStop = autoStopped(obj)

    autoStop = calllib('ps5000aWrap', 'AutoStopped', get(obj, 'unitHandle'));</MCode>
               </Code>
               <Description>AutoStopped(obj) indicates if the device has stopped on collection of the number of samples specified in the call to the ps5000aRunStreaming function.

The autoStop property must have been set to 1.

Input parameters:

obj - the object representing the device.

Output parameters:

autoStop - 0 if the device has not stopped, non-zero if streaming has auto-stopped.</Description>
            </Method>
            <Method>
               <Name>availableData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, startIndex] = availableData(obj)

    startIndex = 0; % Initialise variable to be used as a pointer

    [numSamples, startIndex] = calllib('ps5000aWrap', 'AvailableData', ...
                                get(obj, 'unitHandle'), startIndex);</MCode>
               </Code>
               <Description>AvailableData(obj) indicates the number of samples returned from the driver and shows the start index of the data in the buffer when collecting data in streaming mode.

Input parameters:

obj - the object representing the device.

Output parameters:

numSamples - 0, data is not yet available; Non-zero, the number of samples returned from the driver.
startIndex - an index to the first valid sample in the buffer (when data is available).

Note: the startIndex value is zero-based so should be incremented by 1 when used to retrieve data from the buffer.
</Description>
            </Method>
            <Method>
               <Name>clearTriggerReady</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function triggerCleared = clearTriggerReady(obj)

    triggerCleared = calllib('ps5000aWrap', 'ClearTriggerReady');</MCode>
               </Code>
               <Description>ClearTriggerReady(obj) clears the triggered and triggeredAt flags in relation to streaming mode capture.

Input parameters:

obj - the object representing the device.

Output parameters:

1 - Call successfully completed.</Description>
            </Method>
            <Method>
               <Name>getBlockData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [channelA, channelB, channelC, channelD, numSamples, overflow] = getBlockData(obj, startIndex, segmentIndex, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Check ratio mode is not aggregated
    if(ratioMode ~= evalin('base', 'ps5000aEnuminfo.enPS5000ARatioMode.PS5000A_RATIO_MODE_AGGREGATE'))
        
        % Retrieve channel settings - channel x data field matrix
        channel_settings = cell2mat(obj.UserData.channelSettings(:)); 
        
        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];

        % Overflow indicator
        overflow = 0;

        % Initialise variable for array of libpointers
        p_buffer = libpointer;
        
        % Initialise status
        set_buffer_status = 0;

        % total number of samples to set for data buffers
        total_samples = get(obj, 'numPreTriggerSamples') + get(obj, 'numPostTriggerSamples');
        
        fprintf('getBlockData: Setting up data buffers...\n');

        channel_count = get(obj, 'channelCount');
        
        % For 4 channel models verify power supply is connected
        % Only 2 channels are enabled if the power supply is not connected
        
        if(channel_count == PicoConstants.QUAD_SCOPE)
        
            current_power_state = invoke(obj, 'ps5000aCurrentPowerSource') % State->Source Tom Vettenburg 2014-04-30
        
            if(current_power_state == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED)
           
                channel_count = PicoConstants.DUAL_SCOPE;
                
            end
            
        end
        
        for ch = 1:channel_count

            % Set Data Buffer if channel is enabled - index 1 indicates if
            % channel is enabled
            if(channel_settings(ch,1) == PicoConstants.TRUE)
                
                % Store array of libpointers
                p_buffer(ch) = libpointer('int16Ptr', zeros(total_samples, 1));

                set_buffer_status = invoke(obj, 'ps5000aSetDataBuffer', ...
                    (ch - 1), p_buffer(ch), total_samples, segmentIndex, ratioMode);
                
                if(set_buffer_status ~= PicoStatus.PICO_OK)
                    
                    error('getBlockData: Set Data Buffer for Channel %d error code %d', ...
                        (ch - 1), set_buffer_status);
                    
                end

            end

        end

        fprintf('getBlockData: Retrieving data...\n');
        
        % Call ps5000aGetValues
        [get_values_status, numSamples, overflow] = invoke(obj, ...
            'ps5000aGetValues', startIndex, total_samples, ratio, ratioMode, ...
            segmentIndex, overflow);
        
        if(get_values_status == PicoStatus.PICO_OK)
            
            %fprintf('getBlockData: Assigning data to channel array.\n');
            fprintf('getBlockData: Assigning data to array and converting to milliVolts.\n');
            
            % Retrieve data values for enabled channels
            for ch = 1:channel_count

                if(channel_settings(ch,1) == PicoConstants.TRUE)
                    
                    scope_input_index = channel_settings(ch,3) + 1;
                    voltage_range = PicoConstants.SCOPE_INPUT_RANGES(scope_input_index);
                    
                    buffer_values = adc2mv(p_buffer(ch).Value, voltage_range, get(obj, 'maxADCValue'));

                    switch(ch - 1)

                        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_A')

                            channelA = buffer_values;

                        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_B')

                            channelB = buffer_values;

                        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_C')

                            channelC = buffer_values;

                        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_D')

                            channelD = buffer_values;

                        otherwise

                            % Do nothing

                    end
                    
                end
                
            end
            
            fprintf('getBlockData: Data succesfully retrieved.\n');
            
        else
            
            error('getBlockData: Error retrieving data values - code: %d', get_values_status);
            
        end
        
        
    else
        
        error('getBlockData: Aggregate Mode data collection not supported by this function.');
        
    end</MCode>
               </Code>
               <Description>getBlockData(obj, startIndex, segmentIndex, ratio, ratioMode) returns block mode data with or without downsampling starting at the specified sample number.

Memory for the data arrays is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode  is NOT supported by this function.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
startIndex - a zero-based index that indicates the start point for data collection.
segmentIndex - the number of the memory segment to be used/where the data is stored.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by enumeration from the PS5000A_RATIO_MODE excluding PS5000A_RATIO_MODE_AGGREGATE).


Output parameters:

status - status code returned by the driver.
channelA - an array containing data values (in milliVolts) for channel A.
channelB - an array containing data values (in milliVolts) for channel B.
channelC - an array containing data values (in milliVolts) for channel C.
channelD - an array containing data values (in milliVolts) for channel D.
numSamples - the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.

Channels not enabled or not supported by this device will be returned as an empty array.

Please also refer to the  ps5000aSetDataBuffer and ps5000aGetValues functions as well as the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>getRapidBlockData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [channelA, channelB, channelC, channelD, numSamples, overflow] = getRapidBlockData(obj, numCaptures, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Check ratio mode is not aggregated
    if(ratioMode ~= evalin('base', 'ps5000aEnuminfo.enPS5000ARatioMode.PS5000A_RATIO_MODE_AGGREGATE'))
        
        channel_count = get(obj, 'channelCount');
        
        % Retrieve channel settings - channel x data field matrix
        channel_settings = cell2mat(obj.UserData.channelSettings(:)); 
        
        % For 4 channel models verify power supply is connected
        % Only 2 channels are enabled if the power supply is not connected
        if(channel_count == PicoConstants.QUAD_SCOPE)
        
            current_power_state = invoke(obj, 'ps5000aCurrentPowerSource')  % State->Source Tom Vettenburg 2014-04-30
        
            if(current_power_state == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED)
           
                channel_count = PicoConstants.DUAL_SCOPE;
                
            end
            
        end
        
        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];

        % Initialise variable for array of libpointers
        p_buffer(channel_count, numCaptures) = libpointer;
        
        % Initialise array for status values
        set_buffer_status = zeros(channel_count, numCaptures);

        % total number of samples to set for data buffers
        total_samples = get(obj, 'numPreTriggerSamples') + get(obj, 'numPostTriggerSamples');
        
        %fprintf('getRapidBlockData: Setting up data buffers...\n');
        
        % Create a 2D matrix of libpointers to allocate memory space for
        % each channel and segment combination
        for ch = 1:channel_count

            %fprintf('DEBUG: ch %d\n', ch);
            
            for segment = 1:numCaptures
                
                % Set Data Buffer if channel is enabled
                if(channel_settings(ch,1) == PicoConstants.TRUE)
                    
                    %fprintf('DEBUG: Creating lib pointer %d, %d\n', ch, segment);
                    % Store array of libpointers
                    p_buffer(ch, segment) = libpointer('int16Ptr', zeros(total_samples, 1));
                        
                    %disp('DEBUG: Set buffer');
                    
                    set_buffer_status(ch, segment) = invoke(obj, 'ps5000aSetDataBuffer', ...
                        (ch - 1), p_buffer(ch, segment), total_samples, (segment - 1), ratioMode);

                    if(set_buffer_status(ch, segment) ~= PicoStatus.PICO_OK)

                        error('getRapidBlockData: Set Data Buffer for Channel %d Segment % error code %d', ...
                            (ch - 1), (segment - 1), set_buffer_status);

                    end
                    
                end
                
            end

        end

        fprintf('getRapidBlockData: Retrieving data...\n');
        
        % Call ps5000aGetValuesBulk
        [get_values_bulk_status, numSamples, overflow] = invoke(obj, ...
            'ps5000aGetValuesBulk', total_samples, 0, ...
            (numCaptures - 1), ratio, ratioMode);
        
        if(get_values_bulk_status == PicoStatus.PICO_OK)
            
            %fprintf('getBlockData: Assigning data to channel array.\n');
            fprintf('getRapidBlockData: Converting to milliVolts and assigning to channel array.\n');
            
            % Retrieve data values for enabled channels
            for ch = 1:channel_count

                if(channel_settings(ch,1) == PicoConstants.TRUE)
                    
                    scope_input_index = channel_settings(ch,3) + 1;
                    voltage_range = PicoConstants.SCOPE_INPUT_RANGES(scope_input_index);
                    
                    % Obtain a cell array representing the waveforms for 
                    % the channel
                    buffer_cell = get(p_buffer(ch, :), 'Value');
                    
                    % Combine the cell contents into a total_samples x
                    % numCaptures array
                    buffer_matrix = horzcat(buffer_cell{1:end});
                    
                    buffer_values = adc2mv(buffer_matrix, voltage_range, get(obj, 'maxADCValue'));

                    switch(ch - 1)

                        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_A')

                            channelA = buffer_values;

                        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_B')

                            channelB = buffer_values;

                        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_C')

                            channelC = buffer_values;

                        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_D')

                            channelD = buffer_values;

                        otherwise

                            % Do nothing

                    end
                    
                    clear buffer_cell;
                    clear buffer_matrix;
                    clear buffer_values;
                    
                end
                
            end
            
            fprintf('getRapidBlockData: Data succesfully retrieved.\n\n');
            
            clear p_buffer;
            
        else
            
            error('getRapidBlockData: Error retrieving data values - code: %d', get_values_bulk_status);
            
        end
        
        
    else
        
        error('getRapidBlockData: Aggregate Mode data collection not supported by this function.');
        
    end</MCode>
               </Code>
               <Description>getBlockData(obj, numCaptures, ratio, ratioMode) retrieves waveforms captured using rapid block mode. The waveforms must have been collected sequentially and in the same run.

Memory for the data arrays from segment index 0 to numCaptures - 1 is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode  is NOT supported by this function.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by enumeration from the PS5000A_RATIO_MODE excluding PS5000A_RATIO_MODE_AGGREGATE).

Output parameters:

status - status code returned by the driver.
channelA - an array containing data values (in milliVolts) for channel A.
channelB - an array containing data values (in milliVolts) for channel B.
channelC - an array containing data values (in milliVolts) for channel C.
channelD - an array containing data values (in milliVolts) for channel D.
numSamples -the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.

Channel data will be returned as an array in the form numSamples x numCaptures. Channels not enabled or not supported by this device will be returned as an empty array.

Please also refer to the  ps5000aSetDataBuffer and ps5000aGetValues functions as well as the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>getStreamingLatestValues</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = getStreamingLatestValues(obj)

    status = calllib('ps5000aWrap', 'GetStreamingLatestValues', ...
                get(obj, 'unitHandle'));
            
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>GetStreamingLatestValues(obj) facilitates communication with the underlying driver to return the next block of values to your application when capturing data in streaming mode.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the underlying ps5000aGetStreamingLatestValues function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>getUnitInfo</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, unitInfoValues] = getUnitInfo(obj)

    unit_info_desc = {'Driver version: '; 'USB version: '; 'Hardware version: '; 'Variant: '; ...
        'Batch &amp; Serial: '; 'Cal. Date: '; 'Kernel version: '; 'Digital HW version: '; ...
        'Analogue HW version: '};

    info_line = '               ';

    unitInfoValues = cell(9,1);

    req_size = 15;

    status = zeros(9,1);

    % Loop through and put together information
    for n = 1:9

        [status(n,1), info_line1, req_size]  = calllib('ps5000a', ...
            'ps5000aGetUnitInfo', get(obj, 'unitHandle'), info_line, ... 
            length(info_line), req_size,(n-1));
        
        if(status(n,1) ~= PicoStatus.PICO_OK)
           
            % TBD - Error handling 
        
        end

        unit_info_line = strcat(unit_info_desc(n), info_line1);
        unitInfoValues(n) = cellstr(unit_info_line);
        
    end</MCode>
               </Code>
               <Description>GetUnitInfo(obj) retrieves information about the specified oscilloscope for the following types of information:

1. Driver version
2. USB version
3. Hardware version
4. Variant number
5. Batch &amp; Serial number
6. Calibration date
7. Kernel Version
8. Digital Hardware version
9. Analog Hardware version

Input parameters:

obj - the object representing the device.

Output parameters:

status - an array containing the status codes returned by the driver on each call to the underlying ps5000aGetUnitInfo function.
unitInfoValues - a set of text providing information on the device connected to.

For further information on the underlying ps5000aGetUnitInfo function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>isReady</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function ready = isReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    ready = calllib('ps5000aWrap', 'IsReady', get(obj, 'unitHandle'));</MCode>
               </Code>
               <Description>IsReady(obj) is used to poll the driver to verify that data is ready to be received. Use ps5000aRunStreaming function must have been called prior to calling this function.

Input parameters:

obj - the object representing the device.

Output parameters:

ready - 0, if data is not yet available; non-zero if data is ready to be collected.

</Description>
            </Method>
            <Method>
               <Name>isTriggerReady</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [triggered, triggeredAt] = isTriggerReady(obj)

    triggeredAt = 0; % Initialise value to zero for pointer.

    [triggered, triggeredAt] = calllib('ps5000aWrap', 'IsTriggerReady', ...
        get(obj, 'unitHandle'), triggeredAt);</MCode>
               </Code>
               <Description>IsTriggerReady(obj) indicates whether a trigger has occurred when collecting data in streaming mode, and the location of the trigger point.

Input parameters:

obj - the object representing the device.

Output parameters:

triggered - 0, if the device has not triggered; Non-zero, if the device has been triggered.
triggeredAt - the zero-based index of the sample in the buffer where the trigger occurred.


</Description>
            </Method>
            <Method>
               <Name>ps5000aChangePowerSource</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aChangePowerSource(obj, powerstate)

    status = calllib('ps5000a', 'ps5000aChangePowerSource', ...
                get(obj, 'unitHandle'), powerstate);
            
    if(status == PicoStatus.PICO_OK)
            
        % Turn off channels C and D if USB powered
        if(powerstate == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED &amp;&amp; ... 
                get(obj, 'channelCount') == PicoConstants.QUAD_SCOPE)
            
            channel_c = evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_C');
            channel_d = evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_D');
            
            status_ch_c = invoke(obj, 'ps5000aSetChannel', channel_c, PicoConstants.FALSE, ...
                obj.UserData.channelSettings(3).dc, ...
                obj.UserData.channelSettings(3).range, ...
                obj.UserData.channelSettings(3).offset)
            
            %If successful update channel settings
            if(status_ch_c == PicoStatus.PICO_OK)
               
                obj.UserData.channelSettings(3).enabled = PicoConstants.FALSE;
                
            else
                
                error('ps5000aChangePowerSource calling ps5000aSetChannel for Channel C, error code %d\n', status_ch_c);
                
            end
            
            status_ch_d = invoke(obj, 'ps5000aSetChannel', channel_d, PicoConstants.FALSE, ...
                obj.UserData.channelSettings(4).dc, ...
                obj.UserData.channelSettings(4).range, ...
                obj.UserData.channelSettings(4).offset)
            
            %If successful update channel settings
            if(status_ch_d == PicoStatus.PICO_OK)
               
                obj.UserData.channelSettings(4).enabled = PicoConstants.FALSE;
                
                else
                
                error('ps5000aChangePowerSource calling ps5000aSetChannel for Channel D, error code %d\n', status_ch_d);
                
            end
            
            % Pass information to wrapper dll
            enabled_channels = [obj.UserData.channelsSettings(1).enabled; ...
                obj.UserData.channelsSettings(2).enabled; ...
                obj.UserData.channelsSettings(3).enabled; ...
                obj.UserData.channelsSettings(4).enabled]
            
            calllib('ps5000aWrap', 'setEnabledChannels', get(obj, 'unitHandle'), enabled_channels);
                    
        end
        
    else
        
        error('ps5000aChangePowerSource: Error code %d\n', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aChangePowerSource(obj, powerstate) is called to select the power supply mode.

NOTE: Applies to 4-Channel 5000 A and B Series oscilloscopes only.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
powerstate - the required state of the unit. Either PicoStatus.PICO_POWER_SUPPLY_CONNECTED or  PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED.

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aChangePowerSource function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aCurrentPowerSource</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aCurrentPowerSource(obj)

    status = calllib('ps5000a', 'ps5000aCurrentPowerSource', ...
        get(obj, 'unitHandle'));</MCode>
               </Code>
               <Description>ps3000aCurrentPowerSource(obj) returns the current power state of the device.

NOTE: Applies to 4-Channel 3000 A and B Series oscilloscopes only.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - the current power state of the device or the status code for an invalid handle.

For further information on the ps5000aCurrentPowerSource function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aFlashLed</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aFlashLed(obj, start)

    status = calllib('ps5000a', 'ps5000aFlashLed', get(obj, 'unitHandle'), ...
                start);
            
	if(status ~= PicoStatus.PICO_OK)
           
	% TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aFlashLed(obj, start) flashes the LED on the front of the scope without blocking the calling thread.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
start - the action required:

	&lt; 0 : flash the LED indefinitely.
	0 : stop the LED flashing.
	&gt; 0 : flash the LED start times.

Output parameters:

status - status code returned by the device.

For further information on the ps5000aFlashLed function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetAnalogueOffset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maximumVoltage, minimumVoltage] = ps5000aGetAnalogueOffset(obj, range, coupling)

    % Values to be used for pointers
    max_voltage = 0.0;    
    min_voltage = 0.0;

    [status, maximumVoltage, minimumVoltage] = calllib('ps5000a', ...
        'ps5000aGetAnalogueOffset', get(obj, 'unitHandle'), range, coupling, ...
        max_voltage, min_voltage);
    
    clear max_voltage;
    clear min_voltage;
    
    if(status ~= PicoStatus.PICO_OK)
       
        error('getAnalogueOffset: error code %d\n', status);
    
    end</MCode>
               </Code>
               <Description>ps5000aGetAnalogueOffset(obj, range, coupling) is used to get the maximum and minimum allowable analogue offset for a specific voltage range.

This function may be used with the Test and Measurement Tool.

Input parameters: 

obj - the object representing the device.
range - an enumeration representing the voltage range to be used.
coupling - an enumeration representing the the type of AC/DC coupling used.

Output parameters:

status - status code returned by the driver.
maximumVoltage - the maximum voltage allowed for the range.
minimumVoltage - the minimum voltage allowed for the range.

For further information on the ps5000aGetAnalogueOffset function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.


</Description>
            </Method>
            <Method>
               <Name>ps5000aGetChannelInformation</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ranges, length] = ps5000aGetChannelInformation(obj, channels)

    % Current info supported is PS5000A_CI_RANGES
    info = evalin('base', 'ps5000aEnuminfo.enPS5000AChannelInfo.PS5000A_CI_RANGES');
    probe = 0;
    ranges = zeros(10, 1);
    length = 0;

    [status, ranges, length] = calllib('ps5000a', ...
        'ps5000aGetChannelInformation', get(obj, 'unitHandle'), info, ...
        0, ranges, length, channels);
    
    
    clear info;
    clear probe;
    
    if(status ~= PicoStatus.PICO_OK)
           
       % TBD - Error handling 
        
    end   </MCode>
               </Code>
               <Description>ps5000aGetChannelInformation(obj, channels) queries which ranges are available on a scope device.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channels - the channel for which the range information is required.

Output parameters:

status - status code returned by the driver.
ranges - an array that will be populated with available PS5000A_RANGE enumeration values.
length - the number of elements written to the ranges array.

For further information on the ps5000aGetChannelInformation function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetDeviceResolution</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, resolution] = ps5000aGetDeviceResolution(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    device_res = 0;
    
    [status, device_res] = calllib('ps5000a', 'ps5000aGetDeviceResolution', ...
        get(obj, 'unitHandle'), device_res);
    
    if(status == PicoStatus.PICO_OK)
            
        % Convert to value
    
        switch(device_res)
            
            case evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_8BIT');
                
                device_res = 8;
                
            case evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_12BIT');
                
                device_res = 12;
                
            case evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_14BIT');
                
                device_res = 14;
                
            case evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_15BIT');
                
                device_res = 15;
                
            case evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_16BIT');
                
                device_res = 16;
                
            otherwise
                
                % Do nothing - PICO OK should indicate that the resolution
                % has returned successfully.
        end
        
        set(obj, 'resolution', device_res);
        
        % TBD - Update the bandwidth and memory of the device.

    else
        
        % TBD - Error handling
        
    end</MCode>
               </Code>
               <Description>ps5000aGetDeviceResolution(obj) retrieves the resolution (in bits) that the specified device will run in.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.
resolution - the resolution (in bits) that the device will run in. 

The resolution property is also updated.

For further information on the ps5000aGetDeviceResolution function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetMaxDownSampleRatio</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maxDownSampleRatio] = ps5000aGetMaxDownSampleRatio(obj, numUnaggregatedSamples, downSampleRatioMode, segmentIndex)

    % Value to which the max downsample ration is assigned
    maxDownSampleRatio = 0;        

    [status, maxDownSampleRatio] = calllib('ps5000a', ...
        'ps5000aGetMaxDownSampleRatio', get(obj, 'unitHandle'), numUnaggregatedSamples, ...
            maxDownSampleRatio, downSampleRatioMode, segmentIndex);
        
    if(status ~= PicoStatus.PICO_OK)
           
       % TBD - Error handling 
        
    end   </MCode>
               </Code>
               <Description>ps5000aGetMaxDownSampleRatio(obj, numUnaggregatedSamples, downSampleRatioMode, segmentIndex) returns the maximum downsampling ratio that can be used for a given number of samples in a given downsampling mode.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
numUnaggregatedSamples - the number of unprocessed samples to be downsampled.
downSampleRatioMode - the downsampling mode.
segmentIndex - the memory segment where the data is stored.

Output parameters:

status - status code returned by the driver.
maxDownSampleRatio - the maximum possible downsampling ratio output

For further information on the ps5000aGetMaxDownSampleRatio function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetMaxSegments</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maxSegments] = ps5000aGetMaxSegments(obj)

    % Passing pointer to function
    maxSegments = 0; 

    [status, maxSegments] = calllib('ps5000a', 'ps5000aGetMaxSegments', ...
                                get(obj, 'unitHandle'), maxSegments);
                            
	if(status ~= PicoStatus.PICO_OK)
           
	% TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetMaxSegments(obj) returns the maximum number of segments allowed for the opened device.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the device.
maxSegments - the maximum number of segments allowed.

For further information on the ps5000aGetMaxSegments function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps5000aGetNoOfCaptures</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nCaptures] = ps5000aGetNoOfCaptures(obj)

    nCaptures = 0; % Value for pointer.

    [status, nCaptures] = calllib('ps5000a', 'ps5000aGetNoOfCaptures', ...
                            get(obj, 'unitHandle'), nCaptures);
                        
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetNoOfCaptures(obj) finds out how many captures are available in rapid block mode after runBlock has been called when either the collection completed or the collection of waveforms was interrupted by calling ps5000aStop.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.
nCaptures - the number of available captures that has been collected from calling runBlock.

For further information on the ps5000aGetNoOfCaptures function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetNoOfProcessedCaptures</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nProcessedCaptures] = ps5000aGetNoOfProcessedCaptures(obj)

    nProcessedCaptures = 0;

    [status, nProcessedCaptures] = calllib('ps5000a', 'ps5000aGetNoOfProcessedCaptures', ...
        get(obj, 'unithandle'), nProcessedCaptures);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetNoOfProcessedCaptures(obj, nCaptures) finds out how many captures in rapid block mode have been processed after runBlock has been called when either the collection completed or the collection of waveforms was interrupted by calling ps5000aStop.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.
nProcessedCaptures - the number of available captures that has been collected from calling runBlock.

For further information on the ps5000aGetNoOfProcessedCaptures function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetTimebase</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIntervalNanoSeconds, maxSamples] = ps5000aGetTimebase(obj, timebase, segmentIndex)
    
    timeIntervalNanoSeconds = 0;
    num_samples = get(obj, 'numPreTriggerSamples') + get(obj, 'numPostTriggerSamples');
    max_samples = 0; % Pass data to return the max samples from the driver
    
    [status, timeIntervalNanoSeconds, maxSamples] = calllib('ps5000a', ...
        'ps5000aGetTimebase', get(obj, 'unitHandle'), timebase, num_samples, ...
        timeIntervalNanoSeconds, max_samples, segmentIndex);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end
    
    clear max_samples;
    clear num_samples;</MCode>
               </Code>
               <Description>ps5000aGetTimebase(obj, timebase, segmentIndex) calculates the sampling rate and maximum number of samples for a given timebase under the specified conditions.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
timebase: a timebase index.
segmentIndex: the index of the memory segment to use.

Output parameters:

status - status code returned by the driver.
timeIntervalNanoSeconds: the time interval between readings at the selected timebase.
maxSamples: the maximum number of samples available. 

For further information on the ps5000aGetTimebase function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetTimebase2</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIntervalNanoSeconds, maxSamples] = ps5000aGetTimebase2(obj, timebase, segmentIndex)

    timeIntervalNanoSeconds = 0;
    num_samples = get(obj, 'numPreTriggerSamples') + get(obj, 'numPostTriggerSamples');
    max_samples = 0; % Pass data to return the max samples from the driver
    
    [status, timeIntervalNanoSeconds, maxSamples] = calllib('ps5000a', ...
        'ps5000aGetTimebase2', get(obj, 'unitHandle'), timebase, num_samples, ...
        timeIntervalNanoSeconds, max_samples, segmentIndex);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end
    
    clear max_samples;
    clear num_samples;</MCode>
               </Code>
               <Description>ps5000aGetTimebase2(obj, timebase, segmentIndex) is an upgraded version of ps5000aGetTimebase, and returns the time interval as a float rather than a long integer. This allows it to return sub-nanosecond time intervals.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
timebase: a timebase index.
segmentIndex: the index of the memory segment to use.

Output parameters:

status - status code returned by the driver.
timeIntervalNanoSeconds: the time interval between readings at the selected timebase.
maxSamples: the maximum number of samples available. 

For further information on the ps5000aGetTimebase2 function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetTriggerTimeOffset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeUpper, timeLower, timeUnits] = ps5000aGetTriggerTimeOffset(obj, segmentIndex)

    timeUpper = 0;
    timeLower = 0;
    timeUnits = 0;
    
    [status, timeUpper, timeLower, timeUnits] = calllib('ps5000a', ...
        'ps5000aGetTriggerTimeOffset', get(obj, 'unitHandle'), timeUpper, timeLower, ...
        timeUnits, segmentIndex);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetTriggerTimeOffset(obj, segmentIndex) gets the time, as two 4-byte values, at which the trigger occurred.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
segmentIndex - the number of the memory segment for which the information is required.

Output parameters:

status - status code returned by the driver.
timeUpper - the upper 32 bits of the time at which the trigger point occurred.
timeLower - the lower 32 bits of the time at which the trigger point occurred.
timeUnits - the time units in which timeUpper and timeLower are measured (as an enumeration).

For further information on the ps5000aGetTriggerTimeOffset function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetTriggerTimeOffset64</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, time, timeUnits] = ps5000aGetTriggerTimeOffset64(obj, segmentIndex)

    time = 0;
    timeUnits = 0;

    [status, timetimeUnits] = calllib('ps5000a', ...
        'ps5000aGetTriggerTimeOffset64', get(obj, 'unithandle'), time, ...
        timeUnits, segmentIndex);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetTriggerTimeOffset64(obj, segmentIndex)  gets the time, as a single 64-bit value, at which the trigger occurred.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
segmentIndex -  the number of the memory segment for which the information is required.

Output parameters:

status - status code returned by the driver.
time - the time at which the trigger point occurred.
timeUnits - the time units in which time is measured (as an enumeration).

For further information on the ps5000aGetTriggerTimeOffset64 function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.

</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValues</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps5000aGetValues(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex)

    overflow = 0;
    
    [status, numSamples, overflow] = calllib('ps5000a', 'ps5000aGetValues', ...
        get(obj, 'unitHandle'), startIndex, noOfSamples, downSampleRatio, ....
        downSampleRatioMode, segmentIndex, overflow);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValues(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex) returns block-mode data, with or without downsampling, starting at the specified sample number.

Input parameters:

obj - the object representing the device.
startIndex - a zero-based index that indicates the start point for data collection.
noOfSamples - the number of samples required.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).
segmentIndex - the zero-based number of the memory segment where the data is stored.

Output parameters:

status - status code returned by the driver.
numSamples - the actual number retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.

For further information on the ps5000aGetValues function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesBulk</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps5000aGetValuesBulk(obj, noOfSamples, fromSegmentIndex, toSegmentIndex, downSampleRatio, downSampleRatioMode)

    % overflow must be an array
    overflow_size = (toSegmentIndex - fromSegmentIndex) + 1;
    overflow_ptr = libpointer('int16Ptr', zeros(overflow_size, 1));

    [status, numSamples] = calllib('ps5000a', 'ps5000aGetValuesBulk', ...
        get(obj, 'unitHandle'), noOfSamples, fromSegmentIndex, toSegmentIndex, ... 
        downSampleRatio, downSampleRatioMode, overflow_ptr);
    
    if(status == PicoStatus.PICO_OK)
        
        overflow = overflow_ptr.Value;
        
    else
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValuesBlk(obj, noOfSamples, fromSegmentIndex, toSegmentIndex, downSampleRatio, downSampleRatioMode) retrieves waveforms captured using rapid block mode.

Input parameters:

obj - the object representing the device.
noOfSamples - the number of samples required.
fromSegmentIndex - the first segment from which the waveform should be retrieved.
toSegmentIndex - the last segment from which the waveform should be retrieved.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).

Output parameters:

status - status code returned by the driver.
numSamples - the actual number retrieved from the driver.
overflow - an array of integers equal to or larger than the number of waveforms to be retrieved with each element corresponding to an overlow value as described in the ps5000aGetValues function.

For further information on the ps5000aGetValuesBulk function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesOverlapped</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps5000aGetValuesOverlapped(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex)

    overflow = 0;

    [status, numSamples, overflow] = calllib('ps5000a', ...
        'ps5000aGetValuesOverlapped', get(obj, 'unitHandle'), startIndex, ...
        noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex, overflow)
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValuesOverlapped(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex, overflow) allows you to make a deferred data-collection request, which will later be executed, and the arguments validated, when you call runBlock in block mode.

Input parameters:

obj - the object representing the device.
startIndex - a zero-based index that indicates the start point for data collection.
noOfSamples - the number of samples required.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).
segmentIndex - the zero-based number of the memory segment where the data is stored.

Output parameters:

status - status code returned by the driver.
numSamples - the actual number retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.

For further information on the ps5000aGetValuesOverlapped function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesOverlappedBulk</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps5000aGetValuesOverlappedBulk(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, fromSegmentIndex, toSegmentIndex, overflow)

     % overflow must be an array
    overflow_size = (toSegmentIndex - fromSegmentIndex) + 1;
    overflow = zeros(overflow_size, 1);

    [status, numSamples, overflow] = calllib('ps5000a', ...
        'ps5000aGetValuesOverlappedBulk', get(obj, 'unitHandle'), startIndex, ...
        noOfSamples, downSampleRatio, downSampleRatioMode, fromSegmentIndex, ...
        toSegmentIndex, overflow);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValuesOverlappedBulk(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, fromSegmentIndex, toSegmentIndex, overflow) allows you to make a deferred data-collection request, which will later be executed, and the arguments validated, when you call runBlock in rapid block mode.

Input parameters:

obj - the object representing the device.
startIndex - a zero-based index that indicates the start point for data collection.
noOfSamples - the number of samples required.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).
fromSegmentIndex - the first segment from which the waveform should be retrieved.
toSegmentIndex - the last segment from which the waveform should be retrieved.

Output parameters:

status - status code returned by the driver.
numSamples - the actual number retrieved from the driver.
overflow - an array of integers equal to or larger than the number of waveforms to be retrieved with each element corresponding to an overlow value as described in the ps5000aGetValues function.

For further information on the ps5000aGetValuesOverlappedBulk function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesTriggerTimeOffsetBulk</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timesUpper, timesLower, timeUnits] = ps5000aGetValuesTriggerTimeOffsetBulk(obj, fromSegmentIndex, toSegmentIndex)

    % Define the length of the arrays to be used for capturing time
    % information
    times_array_size = (toSegmentIndex - fromSegmentIndex) + 1;
    
    timesUpper = zeros(times_array_size, 1);
    timesLower = zeros(times_array_size, 1);
    timeUnits = zeros(times_array_size, 1);

    [status, timesUpper, timesLower, timeUnits] = ...
        calllib('ps5000a', 'ps5000aGetValuesTriggerTimeOffsetBulk',
        get(obj, 'unitHandle'), timesUpper, timesLower, timeUnits, ...
        fromSegmentIndex, toSegmentIndex);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aGetValuesTriggerTimeOffsetBulk(obj, fromSegmentIndex, toSegmentIndex) retrieves the time offsets, as lower and upper 32-bit values, for waveforms obtained in rapid block mode.

If using a 64-bit version of MATLAB, please use ps5000aGetValuesTriggerTimeOffsetBulk64.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
fromSegmentIndex - the first segment for which the time offset is required.
toSegmentIndex - the last segment for which the time offset is required.

Output parameters:

status - status code returned by the driver.
timesUpper - an array of integers containing the most significant 32 bits of the time offset for each requested segment index.
timesLower - an array of integers containing the least significant 32 bits of the time offset for each requested segment index.
timeUnits - an array of integers representing the time unit for each time entry.

For further information on the ps5000aGetValuesTriggerTimeOffsetBulk function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aGetValuesTriggerTimeOffsetBulk64</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, times, timeUnits] = ps5000aGetValuesTriggerTimeOffsetBulk64(obj, fromSegmentIndex, toSegmentIndex)

    % Define the length of the arrays to be used for capturing time
    % information
    times_array_size = (toSegmentIndex - fromSegmentIndex) + 1;
    
    times = zeros(times_array_size, 1);
    timeUnits = zeros(times_array_size, 1);

    [status, times, timeUnits] = calllib('ps5000a', ...
        'ps5000aGetValuesTriggerTimeOffsetBulk64', get(obj, 'unitHandle'), ...
        times, timeUnits, fromSegmentIndex, toSegmentIndex)</MCode>
               </Code>
               <Description>ps5000aGetValuesTriggerTimeOffsetBulk64(obj, fromSegmentIndex, toSegmentIndex) retrieves the 64-bit time offsets for waveforms captured in rapid block mode.

If using a 32-bit version of MATLAB, please use ps5000aGetValuesTriggerTimeOffsetBulk instead.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
fromSegmentIndex - the first segment for which the time offset is required.
toSegmentIndex - the last segment for which the time offset is required.

Output parameters:

status - status code returned by the driver.
times - an array of integers holding the time offset for each requested segment index.
timeUnits - an array of integers representing the time unit for each time entry.

For further information on the ps5000aGetValuesTriggerTimeOffsetBulk64 function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aIsReady</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ready] = ps5000aIsReady(obj)

    ready = 0; % Initialise value for pointer

    [status, ready] = calllib('ps5000a', 'ps5000aIsReady', ...
        get(obj, 'unitHandle'), ready);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aIsReady(obj) may be used to poll the driver  to see if it has finished collecting the requested samples after ps5000aRunBlock has been called.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.
ready - indicates the state of the collection. If zero, the device is still collecting. If non-zero, the device has finished collecting and ps5000aGetValues can be used to retrieve the data.

For further information on the ps5000aIsReady function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aIsTriggerOrPulseWidthQualifierEnabled</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, triggerEnabled, pwqEnabled] = ps5000aIsTriggerOrPulseWidthQualifierEnabled(obj)

    % Allocate values for variables
    triggerEnabled = 0;
    pwqEnabled = 0;

    [status, triggerEnabled, pwqEnabled] = calllib('ps5000a', ...
        'ps5000aIsTriggerOrPulseWidthQualifierEnabled', get(obj, 'unitHandle'), ...
        triggerEnabled, pwqEnabled);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aIsTriggerOrPulseWidthQualifierEnabled(obj) discovers whether a trigger, or pulse width triggering, is enabled.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the device.
triggerEnabled - indicates if trigger is set.
pwqEnabled - indicates if pulse widtrh qualifier is set.

For further information on the ps5000aIsTriggerOrPulseWidthQualifierEnabled function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aMaximumValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aMaximumValue(obj)

    max_val_ptr = 0;

    [status, obj.UserData.maxADCValue]  = calllib('ps5000a', ...
            'ps5000aMaximumValue', get(obj, 'unitHandle'), max_val_ptr);

    if(status == PicoStatus.PICO_OK)
    
        % Maximum value is stored in the driver 
        set(obj, 'maxADCValue', obj.UserData.maxADCValue);
    
    else
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aMaximumValue(obj) sets the maxADCValue property corresponding to the  maximum ADC count returned by calls to get values.

For 8-bit resolution mode the maximum ADC count is 32512.

For 12, 14, 15 and 16-bit resolution modes, the maximum ADC count is 32767.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aMaximumValue function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.

</Description>
            </Method>
            <Method>
               <Name>ps5000aMemorySegments</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nMaxSamples] = ps5000aMemorySegments(obj, nSegments)

    nMaxSamples = 0; % Initialise value for pointer

    [status, nMaxSamples] = calllib('ps5000a', 'ps5000aMemorySegments', ...
        get(obj, 'unitHandle'), nSegments, nMaxSamples);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aMemorySegments(obj, nSegments) sets the number of memory segments that the scope will use.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
nSegments - the number of segments required from:

1 to 65,535: PicoScope 5242A/B, 5243A/B, 5442A/B, 5443A/B
1 to 125,000: PicoScope 5244A, 5444A
1 to 250,000: PicoScope 5244B, 5444B

Output parameters:

status - status code returned by the driver.
nMaxSamples - the number of samples available in each segment.

For further information on the ps5000aMemorySegments function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aMinimumValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aMinimumValue(obj)

    min_val_ptr = 0; % Initialise pointer

    [status, obj.UserData.minADCValue]  = calllib('ps5000a', ...
            'ps5000aMinimumValue', get(obj, 'unitHandle'), min_val_ptr);

    if(status == PicoStatus.PICO_OK)
        
        % Store value in driver    
        set(obj, 'minADCValue', obj.UserData.minADCValue);
    
    else
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aMinimumValue(obj) sets the minValue property corresponding to the minimum ADC count returned by calls to get values.

For 8-bit resolution mode, the minimum ADC count is -32512.

For 12, 14, 15 and 16-bit resolution modes, the minimum ADC count is -32767.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aMinimumValue function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps5000aNoOfStreamingValues</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, noOfValues] = ps5000aNoOfStreamingValues(obj)

    noOfValues = 0; % Initialise value for use as pointer.

    [status, noOfValues] = calllib('ps5000a', 'ps5000aNoOfStreamingValues', ...
        get(obj, 'unitHandle'), noOfValues);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aNoOfStreamingValues(obj) returns the number of samples available after data collection in streaming mode. Call this function after calling ps5000aStop.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.
noOfValues - the number of samples.

For further information on the ps5000aNoOfStreamingValues function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aPingUnit</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aPingUnit(obj)

    status = calllib('ps5000a', 'ps5000aPingUnit', get(obj, 'unitHandle'));
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end </MCode>
               </Code>
               <Description>ps5000aPingUnit(obj) can be used to check that the already opened device is still connected to the USB port and communication is successful.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aPingUnit function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aRunStreaming</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, sampleInterval, sampleIntervalTimeUnitsStr] = ps5000aRunStreaming(obj, downSampleRatio, downSampleRatioMode, overviewBufferSize)

    % Calculate sampleInterval and sampleIntervalTimeUnits according to
    % streamingInterval property set. Property is defined in seconds.

    streaming_interval = get(obj, 'streamingInterval'); 
    
    femtoseconds_enum = evalin('base', 'ps5000aEnuminfo.enPS5000ATimeUnits.PS5000A_FS');
    picoseconds_enum = evalin('base', 'ps5000aEnuminfo.enPS5000ATimeUnits.PS5000A_PS');
    nanoseconds_enum = evalin('base', 'ps5000aEnuminfo.enPS5000ATimeUnits.PS5000A_NS');
    microseconds_enum = evalin('base', 'ps5000aEnuminfo.enPS5000ATimeUnits.PS5000A_US');
    milliseconds_enum = evalin('base', 'ps5000aEnuminfo.enPS5000ATimeUnits.PS5000A_MS');
    seconds_enum = evalin('base', 'ps5000aEnuminfo.enPS5000ATimeUnits.PS5000A_S');
    
    sampleIntervalTimeUnits = seconds_enum;
    
    if(streaming_interval &lt; 1e-12) % Femtoseconds (unlikely with USB 2.0)
        
        sampleInterval = streaming_interval * 1e15;
        sampleIntervalTimeUnits = femtoseconds_enum;
        
    elseif(streaming_interval &gt;= 1e-12 &amp;&amp; streaming_interval &lt; 1e-9) % Picoseconds
        
        sampleInterval = streaming_interval * 1e12;
        sampleIntervalTimeUnits = picoseconds_enum;
        
	elseif(streaming_interval &gt;= 1e-9 &amp;&amp; streaming_interval &lt; 1e-6) % Nanoseconds
        
        sampleInterval = streaming_interval * 1e9;
        sampleIntervalTimeUnits = nanoseconds_enum;
        
	elseif(streaming_interval &gt;= 1e-6 &amp;&amp; streaming_interval &lt; 1e-3) % Microseconds
        
        sampleInterval = streaming_interval * 1e6;
        sampleIntervalTimeUnits = microseconds_enum;
        
    elseif(streaming_interval &gt;= 1e-3 &amp;&amp; streaming_interval &lt; 1) % Milliseconds
        
        sampleInterval = streaming_interval * 1e3;
        sampleIntervalTimeUnits = milliseconds_enum;
            
    else 
        
        % Already defined seconds
        
    end
            
    [status, sampleInterval] = calllib('ps5000a', 'ps5000aRunStreaming', ...
        get(obj, 'unitHandle'), sampleInterval, sampleIntervalTimeUnits, ...
        get(obj, 'numPreTriggerSamples'), get(obj, 'numPostTriggerSamples'), ...
        get(obj, 'autoStop'), downSampleRatio, downSampleRatioMode, overviewBufferSize);
    
    if(status == PicoStatus.PICO_OK)
           
        fprintf('ps5000aRunStreaming:- Sample interval %d', sampleInterval);
        
        switch(sampleIntervalTimeUnits)
       
            case femtoseconds_enum

                sampleIntervalTimeUnitsStr = 'fs';
                
            case picoseconds_enum

                sampleIntervalTimeUnitsStr = 'ps';

            case nanoseconds_enum

                sampleIntervalTimeUnitsStr = 'ns';

            case microseconds_enum

                sampleIntervalTimeUnitsStr = 'us';

            case milliseconds_enum

                sampleIntervalTimeUnitsStr = 'ms';

            case seconds_enum

                sampleIntervalTimeUnitsStr = 's';
            
            otherwise
                
                % Do nothing
        
        end
        
        fprintf('%s\n', sampleIntervalTimeUnitsStr);
        
        clear streaming_interval;
        clear femtoseconds_enum;
        clear picoseconds_enum;
        clear nanoseconds_enum;
        clear microseconds_enum;
        clear milliseconds_enum;
        clear seconds_enum;
        
    % Check for Power connection
    elseif(status == PicoStatus.PICO_POWER_SUPPLY_CONNECTED || ...
                status == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED || ...
                status == PicoStatus.PICO_POWER_SUPPLY_UNDERVOLTAGE)
    
        status = invoke(obj, 'ps5000aChangePowerSource', status)
        
    else
        
        error('ps5000aRunStreaming: Error code %d\n', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aRunStreaming(obj, sampleInterval, sampleIntervalTimeUnits, maxPreTriggerSamples, maxPostTriggerSamples, autoStop, downSampleRatio, downSampleRatioMode, overviewBufferSize) function tells the oscilloscope to start collecting data in streaming mode. Use the wrapper function GetStreamingLatestValues to obtain the values. 

Input parameters:

obj - the object representing the device.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode -  which downsampling mode to use (an enumeration from the PS5000A_RATIO_MODE range).
overviewBufferSize - the size of the overview buffers (temporary buffers used for storing the data before returning it to the application).

Output parameters:

status - status code returned by the driver.
sampleInterval - the actual time interval used.
sampleIntervalTimeUnitsStr - a string representing the time unit for the sampling interval.

For further information on the ps5000aRunStreaming function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.

</Description>
            </Method>
            <Method>
               <Name>ps5000aSetBandwidthFilter</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetBandwidthFilter(obj, channel, bandwidth)

    if(get(obj, 'channelCount') == PicoConstants.QUAD_SCOPE)
        
        if(channel &lt; evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_A') 
            || channel &gt;= evalin('base', ' ps5000aEnuminfo.enPS5000AChannel.PS5000A_MAX_CHANNELS'))
            
            error('ps5000aSetBandwidthFilter: Invalid channel number (should be 0 (A) to 3 (D)');    
            
        end
        
    else
       
        error('ps5000aSetBandwidthFilter: Function is only supported by 4-channel 5000 series oscilloscopes.');
        
    end

    if(get(obj, 'channelCount') == PicoConstants.PicoConstants.DUAL_SCOPE)
        
    if(bandwidth ~= ('base', 'ps5000aEnuminfo.enPS5000ABandwidthLimiter.PS5000A_BW_FULL') ...
            || bandwidth ~= evalin('base', 'ps5000aEnuminfo.enPS5000ABandwidthLimiter.PS5000A_BW_20MHZ'))
        
       error('ps5000aSetBandwidthFilter: bandwidth must be 0 (Full) or 1 (20MHz).')
        
    end

    status = calllib('ps5000a', 'ps5000aSetBandwidthFilter', ...
                get(obj, 'unitHandle'), channel, bandwidth);
   
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aSetBandwidthFilter(obj, channel, bandwidth) specifies the bandwidth limit.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channel - the channel to be configured (an enumeration from the PS5000A_CHANNEL range).
bandwidth - the bandwidth is either 0 (Full Bandwidth) or 1 (20MHz).

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aSetBandwidthFilter function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetChannel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetChannel(obj, channel, enabled, type, range, analogueOffset)

    status = calllib('ps5000a', 'ps5000aSetChannel', get(obj, 'unitHandle'), ...
                channel, enabled, type, range, analogueOffset);
     
    %disp('DEBUG: ps5000aSetChannel')  
    % Obtain information is contained in UserData.channelSettings
    % info = obj.UserData
    
    % Convert cell array to channel x data field matrix
    channel_settings = cell2mat(obj.UserData.channelSettings(:));
            
	if(status == PicoStatus.PICO_OK)
        
        switch(channel)
            
            case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_A')
                
                channel_settings(1,1) = enabled;
                channel_settings(1,2) = type;
                channel_settings(1,3) = range;
                channel_settings(1,4) = analogueOffset; 
                
            case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_B')
                
                channel_settings(2,1) = enabled;
                channel_settings(2,2) = type;
                channel_settings(2,3) = range;
                channel_settings(2,4) = analogueOffset; 

            case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_C')
                
                channel_settings(3,1) = enabled;
                channel_settings(3,2) = type;
                channel_settings(3,3) = range;
                channel_settings(3,4) = analogueOffset;  
                
            case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_D')
                
                channel_settings(4,1) = enabled;
                channel_settings(4,2) = type;
                channel_settings(4,3) = range;
                channel_settings(4,4) = analogueOffset; 
                
            otherwise
                
                % Do nothing
                    
        end
        
        %obj.UserData.channelSettings
        set(obj, 'channelSettings', channel_settings);
        
        % Information to be passed to the wrapper dll
        enabled_channels = zeros(PicoConstants.QUAD_SCOPE, 1);
        
        %disp('Setting channels')
        
        switch(get(obj, 'channelCount'))
            
            case PicoConstants.DUAL_SCOPE
           
                % Only channels A and B
            enabled_channels = [channel_settings(1,1); ...
                channel_settings(2,1); 0; 0];
            
            case PicoConstants.QUAD_SCOPE
                
            enabled_channels = [channel_settings(1,1); ...
                channel_settings(2,1); ...
                channel_settings(3,1); ...
                channel_settings(4,1)];
            
            otherwise
        
                % Do nothing
            
        end
        
        set_enabled_channels_status = calllib('ps5000aWrap', ...
            'setEnabledChannels', get(obj, 'unitHandle'), enabled_channels);
        
    else
        
        error('ps5000aSetChannel: error code %d\n', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetChannel(obj, channel, enabled, type, range, analogueOffset) specifies whether an input channel is to be enabled, its input coupling type, voltage range, analog offset and bandwidth limit.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channel - the channel to be configured (an enumeration from the PS5000A_CHANNEL range).
enabled - set to TRUE (1) to enable the channel, FALSE (0) otherwise.
type - the impedance and coupling type (an enumeration from the PS5000A_COUPLING range).
range - the input voltage range (an enumeration from the PS5000A_RANGE range).
analogueOffset - a voltage to add to the input channel before digitization.

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aSetChannel function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetDataBuffer</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetDataBuffer(obj, channel, buffer, bufferLth, segmentIndex, mode)

    status = calllib('ps5000a', 'ps5000aSetDataBuffer', get(obj, 'unitHandle'), ...
                channel, buffer, bufferLth, segmentIndex, mode);
            
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps5000aSetDataBuffer: code %d', status);
        
    end</MCode>
               </Code>
               <Description>ps5000aSetDataBuffer(obj, channel, buffer, bufferLth, segmentIndex, mode) tells the driver where to store the data, either unprocessed or downsampled, that will be returned after the next call to one of the GetValues functions.

Input parameters:

obj - the object representing the device.
channel - the channel to which the buffer corresponds (an enumeration from the PS5000A_CHANNEL range).
buffer - a libpointer to a 1-D array to receive the data values for the channel.
bufferLth - the length of the buffer array.
segmentIndex - the number of the memory segment to be used.
mode - the downsampling mode (an enumeration from the PS5000A_RATIO_MODE range).

Output parameters:

status - status code returned by the device.

If capturing data in streaming mode without aggregation, buffer must also be passed as the driverBuffer argument for the setAppAndDriverBuffers function call.

For further information on the ps5000aSetDataBuffer function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.

</Description>
            </Method>
            <Method>
               <Name>ps5000aSetDataBuffers</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetDataBuffers(obj, channel, pBufferMax, pBufferMin, bufferLth, segmentIndex, ratioMode)

    status = calllib('ps5000a', 'ps5000aSetDataBuffers', ...
        get(obj, 'unitHandle'), channel, pBufferMax, pBufferMin, bufferLth, ...
        segmentIndex, ratioMode);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aSetDataBuffers(obj, channel, pBufferMax, pBufferMin, bufferLth, segmentIndex, ratioMode) tells the driver the location of one or two buffers for receiving data.

If aggregate mode is not being used, then ps5000aSetDataBuffer can optionally be used instead.

Input parameters:

obj - the object representing the device.
channel -  the channel for which to set the buffers (an enumeration from the PS5000A_CHANNEL range).
pBufferMax - a libpointer to a 1-D array to receive the maximum data values in aggregation mode, or the non-aggregated values otherwise.
pBufferMin -  a libpointer to a 1-D array to receive the minimum aggregated data values. Not used in other downsampling modes.
bufferLth - the size of the arrays to which pBufferMax and pBufferMin are pointers.
segmentIndex - the number of the memory segment to be used.
mode - the downsampling mode to use (an enumeration from the PS5000A_RATIO_MODE range).

Output parameters:

status - status code returned by the device.

If capturing data in streaming mode with aggregation, pBufferMax and pBufferMin must also be passed as the driverMaxBuffer and driverMinBuffer arguments respectively for the setMaxMinAppAndDriverBuffers function call.

For further information on the ps5000aSetDataBuffers function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetDeviceResolution</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetDeviceResolution(obj, resolution)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Initialise a value for the resolution.
    device_res = evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_8BIT');
    
    % Verify resolution is valid
    switch(resolution)
        
        case 8
            
            % No change to device_res
            
        case 12
            
            device_res = evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_12BIT');
            
        case 14
            
            device_res = evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_14BIT');
            
        case 15
            
            device_res = evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_15BIT');
            
        case 16

            device_res = evalin('base', 'ps5000aEnuminfo.enPS5000ADeviceResolution.PS5000A_DR_16BIT');
            
        otherwise
        
            error('ps5000aSetDeviceResolution: Resolution must be 8, 12, 14, 15 or 16 bits.');
            
    end
    
    % Find number of active channels
    
    channel_settings = obj.UserData.channelSettings;
    
    % Array to represent channels enabled
    enabled_channels = zeros(PicoConstants.QUAD_SCOPE, 1);
    
    % If &gt; 1 channel &amp; 16-bit
    
    % If &gt; 2 channels &amp; 15-bit
    
    
    status = calllib('ps5000a', 'ps5000aSetDeviceResolution', ...
        get(obj, 'unitHandle'), device_res);
    
    if(status == PicoStatus.PICO_OK)
           
        % Set local resolution value
        set(obj, 'resolution', resolution);
        
        fprintf('ps5000aSetDeviceResolution: Device resolution set to %d bits.\n\n', resolution);
        
        % Set the maximum and minimum ADC count value
        
        status = invoke(obj, 'ps5000aMaximumValue');
        status = invoke(obj, 'ps5000aMinimumValue');
        
        % Depending on resolution set:
        %   First range
        %   Bandwidth
        %   Buffer memory
        
        if(resolution &lt; 16)
           
            model_variant = obj.InstrumentModel; % Added any(.) Tom Vettenburg 2014-04-30
                
                if(any(strfind(model_variant, '5242')) || any(strfind(model_variant, '5442')))
                    
                    set(obj, 'bandwidth', PicoConstants.BANDWIDTH_60MHZ);
                    
                elseif(any(strfind(model_variant, '5243')) || any(strfind(model_variant, '5443')))
                    
                    set(obj, 'bandwidth', PicoConstants.BANDWIDTH_100MHZ);
                    
                elseif(any(strfind(model_variant, '5244')) || any(strfind(model_variant, '5444')))
                    
                    set(obj, 'bandwidth', PicoConstants.BANDWIDTH_200MHZ);
                        
                else
                    
                    % Do nothing
                
                end
                
        else
            
            set(obj, 'bandwidth', PicoConstants.BANDWIDTH_60MHZ);
            
        end
            
        % If valid, and 12-bits or greater, halve the memory and update the bandwidth if required
        if(resolution &gt;= 12)
            
            % Select the correct first range
            % TBD - Buffer memory
            if(resolution == 12)
                
                set(obj, 'firstRange',  evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_20MV'));
            
            else
                
                set(obj, 'firstRange',  evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_50MV'));
                
            end
            
        else
            
            % Set defaults for 8-bit resolution
            set(obj, 'firstRange',  evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_10MV'));
            
        end
           
    else
        
        error('ps5000aSetDeviceResolution: Device resolution not set.');
        
    end</MCode>
               </Code>
               <Description>ps5000aSetDeviceResolution(obj, resolution) sets the new resolution. 

When using 12 bits or more the memory is halved. When using 15-bit resolution only 2 channels can be enabled to capture data, and when using 16-bit resolution only one channel is available.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
resolution - the desired resolution in bits (8, 12, 14, 15 or 16).

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aSetDeviceResolution  function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps5000aSetEts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, sampleTimePicoSeconds] = ps5000aSetEts(obj, mode, etsCycles, etsInterleave)

    sampleTimePicoSeconds = 0; % Initialise to pass as pointer
    
    if(mode == evalin('base', 'ps5000aEnuminfo.enPS5000AEtsMode.PS5000A_ETS_OFF'))
        
        [status, sampleTimePicoSeconds] = calllib('ps5000a', 'ps5000aSetEts', ...
            get(obj, 'unitHandle'), mode, etsCycles, etsInterleave, sampleTimePicoSeconds);
    
    elseif(etsCycles &gt; 0 &amp;&amp; etsInterleave &gt; 0)
    
        % Confirm if number of cycles or interleave is correct

        ets_ratio = etsCycles / etsInterleave;

        if(ets_ratio &lt; 2 || ets_ratio &gt; 5)

            error('ps5000aSetEts: etsCycles must be between two and five times the value of etsInterleave');

        end

        switch(obj.InstrumentModel)

                case PS5000AConstants.MODEL_PS5242A

                    if(etsCycles &gt; PS5000AConstants.PS5242A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 125).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5242A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 10).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5242B
                    
                    if(etsCycles &gt; PS5000AConstants.PS5242A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 125).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5242A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 10).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5243A

                    if(etsCycles &gt; PS5000AConstants.PS5243A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 250).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5243A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 20).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5243B

                    if(etsCycles &gt; PS5000AConstants.PS5243A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 250).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5243A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 20).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5244A

                    if(etsCycles &gt; PS5000AConstants.PS5244A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 500).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5244A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 40).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5244B

                    if(etsCycles &gt; PS5000AConstants.PS5244A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 500).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5244A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 40).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5442A

                    if(etsCycles &gt; PS5000AConstants.PS5242A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 125).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5242A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 10).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5442B
                    
                    if(etsCycles &gt; PS5000AConstants.PS5242A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 125).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5242A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 10).')
                        
                    end
                    
                    case PS5000AConstants.MODEL_PS5443A

                    if(etsCycles &gt; PS5000AConstants.PS5243A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 250).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5243A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 20).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5443B

                    if(etsCycles &gt; PS5000AConstants.PS5243A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 250).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5243A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 20).')
                        
                    end
                
                case PS5000AConstants.MODEL_PS5444A

                    if(etsCycles &gt; PS5000AConstants.PS5244A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 500).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5244A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 40).')
                        
                    end
                    
                case PS5000AConstants.MODEL_PS5444B

                    if(etsCycles &gt; PS5000AConstants.PS5244A_MAX_ETS_CYCLES)
                       
                        error('ps5000aSetEts: etsCycles out of range (Max. 500).')
                           
                    end
                    
                    if(etsInterleave &gt; PS5000AConstants.PS5244A_MAX_ETS_INTERLEAVE)
                       
                        error('ps5000aSetEts: etsInterleave out of range (Max. 40).')
                        
                    end
        
            otherwise
        
                % Do nothing
        end
        
        [status, sampleTimePicoSeconds] = calllib('ps5000a', 'ps5000aSetEts', ...
            get(obj, 'unitHandle'), mode, etsCycles, etsInterleave, sampleTimePicoSeconds);
        
    else
        
        error('ps5000aSetEts: etsCycles and etsInterleave must both be greater than 0.')
        
    end</MCode>
               </Code>
               <Description>ps5000aSetEts(obj, mode, etsCycles, etsInterleave) is used to enable or disable ETS (equivalent-time sampling) and to set the ETS parameters.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
mode - must be one of the following:

	PS5000A_ETS_OFF    (0)
	PS5000A_ETS_FAST  (1)
	PS5000A_ETS_SLOW (2)

etsCycles - the number of cycles to store; must be greater than zero and between 2 and 5 times greater than etsInterleave.
etsInterleave - the number of waveforms to combine into a single ETS capture. Must be greater than zero.

Output parameters:

status - status code returned by the driver.
sampleTimePicoSeconds - the effective sampling interval of the ETS data.

For further information on the ps5000aSetEts function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetEtsTimeBuffer</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, etsBuffer] = ps5000aSetEtsTimeBuffer(obj, bufferLth)

    % Pointer to array
    p_buffer = libpointer('int64Ptr', zeros(bufferLth, 1));

    status = calllib('ps5000a', 'ps5000aSetEtsTimeBuffer', ...
        get(obj, 'unitHandle'), p_buffer, bufferLth);
    
    etsBuffer = p_buffer.Value;
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aSetEtsTimeBuffer(obj, bufferLth) tells the driver where to find your application's ETS time buffers.

If using a 32-bit version of MATLAB, use ps5000aSetEtsTimeBuffers instead.

Input parameters:

obj - the object representing the device.
bufferLth - the number of ETS samples.

Output parameters:

status - status code returned by the device.
etsBuffer - a 1-D array of 64-bit words, each representing the time in picoseconds at which the sample was captured.

For further information on the ps5000aSetEtsTimeBuffer function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps5000aSetEtsTimeBuffers</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, etsTimeUpper, etsTimeLower] = ps5000aSetEtsTimeBuffers(obj, bufferLth)

    % Pointer to arrays
    p_buffer_upper = libpointer('int32Ptr', zeros(bufferLth, 1));
    p_buffer_lower = libpointer('int32Ptr', zeros(bufferLth, 1));

    status = calllib('ps5000a', 'ps5000aSetEtsTimeBuffer', ...
        get(obj, 'unitHandle'), p_buffer_upper, p_buffer_lower, bufferLth);
    
    etsTimeUpper = p_buffer_upper.Value;
    etsTimeLower = p_buffer_lower.Value;
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aSetEtsTimeBuffers(obj, bufferLth) tells the driver where to find your application's ETS time buffers. These buffers contain the timing information for each ETS sample after you run a block mode ETS capture.

For 64-bit versions of MATLAB please use ps5000aSetEtsTimeBuffer instead.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
bufferLth - the number of ETS samples.

Output parameters:

status - status code returned by the device.
etsTimeUpper - an array of 32-bit words, each representing the upper 32 bits of the time in picoseconds at which the sample was captured.
etsTimeLower - an array of 32-bit words, each representing the lower 32 bits of the time in picoseconds at which the sample was captured.

For further information on the ps5000aSetEtsTimeBuffers function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetNoOfCaptures</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetNoOfCaptures(obj, nCaptures)

    status = calllib('ps5000a', 'ps5000aSetNoOfCaptures', ...
        get(obj, 'unitHandle'), nCaptures);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aSetNoOfCaptures(obj, nCaptures) sets the number of captures to be collected in one run of rapid block mode.

If this function is not called prior to a run, only a single waveform will be captured.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
nCaptures - the number of waveforms to capture in one run.

Output parameters:

status - status code returned by the device.

For further information on the ps5000aSetNoOfCaptures function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetPulseWidthQualifier</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetPulseWidthQualifier(obj, conditions, nConditions, direction, lower, upper, type)

    max_pwq_conditions = evalin('base'), 'PS5000aConstants.MAX_PULSE_WIDTH_QUALIFIER_COUNT');
    
    % Verify number of conditions is set correctly
    if(nConditions &gt; 0 &amp;&amp; nConditions &lt;= max_pwq_conditions)
            
        status = calllib('ps5000a', 'ps5000aSetPulseWidthQualifier', ...
            get(obj, 'unitHandle'), conditions, nConditions, direction, lower, ...
            upper, type)
        
    else
       
        error('ps5000aSetPulseWidthQualifier: Number of PWQ conditions must be between 0 and %d', max_pwq_conditions);
        
    end
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>ps5000aSetPulseWidthQualifier(obj, conditions, nConditions, direction, lower, upper, type) sets up pulse-width qualification, which can be used on its own for pulse width triggering or combined with window triggering to produce more complex triggers.

If using the Test and Measurement Tool, please use SetPulseWidthQualifier.

Input parameters:

obj - the object representing the device.
pwqConditions -  an array of tPS5000APwqConditions structures specifying the conditions that should be applied to each channel.
nConditions - the number of elements in the conditions array.
direction - the direction of the signal required for the pulse width trigger to fire (a PS5000A_THRESHOLD_DIRECTION enumeration).
lower - the lower limit of the pulse-width counter with relation to number of samples captured on the device.
upper - the upper limit of the pulse-width counter with relation to number of samples captured on the device.
type - the pulse-width type (a PS5000A_PULSE_WIDTH_TYPE enumeration).

Output parameters:

status - status code returned by the device.

For further information on the  ps5000aSetPulseWidthQualifer function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSetTriggerChannelDirections</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSetTriggerChannelDirections(obj, channelA, channelB, channelC, channelD, ext)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Aux parameter not used.
    aux = 0;
    
    status = calllib('ps5000a', 'ps5000aSetTriggerChannelDirections', ...
        get(obj, 'unitHandle'), channelA, channelB, channelC, channelD, ext, aux);
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end </MCode>
               </Code>
               <Description>ps5000aSetTriggerChannelDirections(obj, channelA, channelB, channelC, channelD, ext) sets the direction of the trigger for each channel.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channelA, channelB,channelC, channelD, ext - the direction in which the signal must pass through the threshold to activate the trigger (an enumeration from the PS5000A_THRESHOLD_DIRECTION range).

Output parameters:

status - status code returned by the device.

For further information on the ps5000aSetTriggerChannelDirections function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aSigGenSoftwareControl</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aSigGenSoftwareControl(obj, state)

    status = calllib('ps5000a', 'ps5000aSigGenSoftwareControl', ...
                get(obj, 'unitHandle'), state);
            
	if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end </MCode>
               </Code>
               <Description>ps5000aSigGenSoftwareControl(obj, state) causes a trigger event, or starts and stops gating.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
state - sets the trigger gate high or low when the trigger type is set to either SIGGEN_GATE_HIGH or SIGGEN_GATE_LOW.

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aSigGenSoftwareControl please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps5000aStop</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps5000aStop(obj)

    status = calllib('ps5000a', 'ps5000aStop', get(obj, 'unitHandle'));
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps5000aStop: error code %d\n', status)
        
    end</MCode>
               </Code>
               <Description>ps5000aStop(obj) stops the scope device from sampling data.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.

For further information on the ps5000aStop function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>resetDevice</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function resetDevice(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    fprintf('Setting Device Parameters...\n\n');
    
    range_10mV = evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_10MV');
    range_20mV = evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_20MV');
    range_50mV = evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_50MV');
    range_20V = evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_20V');

    % Set device parameters
    switch(obj.InstrumentModel)

            case PS5000aConstants.MODEL_PS5242A

                obj.UserData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_FUNCT_GEN;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
                obj.UserData.hasHardwareEts = PicoConstants.FALSE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_16MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_60MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;

            case PS5000aConstants.MODEL_PS5242B

                obj.UserData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_AWG;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_16KS;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_200MHZ;
                obj.UserData.hasHardwareEts = PicoConstants.FALSE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_32MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_60MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                
            case PS5000aConstants.MODEL_PS5243A

                obj.UserData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_FUNCT_GEN;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
                obj.UserData.hasHardwareEts = PicoConstants.TRUE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_64MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;

            case PS5000aConstants.MODEL_PS5243B

                obj.UserData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_AWG;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_32KS;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_200MHZ;
                obj.UserData.hasHardwareEts = PicoConstants.TRUE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_128MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                
            case PS5000aConstants.MODEL_PS5244A

                obj.UserData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_FUNCT_GEN;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
                obj.UserData.hasHardwareEts = PicoConstants.TRUE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;

            case PS5000aConstants.MODEL_PS5244B

                obj.UserData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_AWG;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_48KS;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_200MHZ;
                obj.UserData.hasHardwareEts = PicoConstants.TRUE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_512MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                  
            case PS5000aConstants.MODEL_PS5442A

                obj.UserData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_FUNCT_GEN;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
                obj.UserData.hasHardwareEts = PicoConstants.FALSE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_16MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_60MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                
            case PS5000aConstants.MODEL_PS5442B

                obj.UserData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_AWG;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_16KS;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_200MHZ;
                obj.UserData.hasHardwareEts = PicoConstants.FALSE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_32MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_60MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                
            case PS5000aConstants.MODEL_PS5443A

                obj.UserData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_FUNCT_GEN;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
                obj.UserData.hasHardwareEts = PicoConstants.TRUE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_64MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                
            case PS5000aConstants.MODEL_PS5443B

                obj.UserData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_AWG;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_32KS;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_200MHZ;
                obj.UserData.hasHardwareEts = PicoConstants.TRUE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_128MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                
            case PS5000aConstants.MODEL_PS5444A

                obj.UserData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_FUNCT_GEN;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
                obj.UserData.hasHardwareEts = PicoConstants.TRUE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                
            case PS5000aConstants.MODEL_PS5444B

                obj.UserData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_10mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_AWG;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_48KS;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_200MHZ;
                obj.UserData.hasHardwareEts = PicoConstants.TRUE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_512MS;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;
                
            otherwise

                obj.InstrumentModel = PS5000aConstants.MODEL_NONE;
                obj.UserData.channelCount = 0;
                obj.UserData.digitalPorts = 0;
                obj.UserData.firstRange = range_50mV;
                obj.UserData.lastRange = range_20V;
                obj.UserData.sigGenType = PicoConstants.SIG_GEN_NONE;
                obj.UserData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;
                obj.UserData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;
                obj.UserData.hasHardwareEts = PicoConstants.FALSE;
                obj.UserData.bufferMemory = PicoConstants.BUFFER_MEMORY_ZERO;
                obj.UserData.bandwidth = PicoConstants.BANDWIDTH_ZERO;
                obj.UserData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_ZERO;
                
                error('Unit not supported');

    end

    % Set the values in the driver

    set(obj, 'channelCount', obj.UserData.channelCount);
    set(obj, 'digitalPorts', obj.UserData.digitalPorts);
    set(obj, 'firstRange', obj.UserData.firstRange);
    set(obj, 'lastRange', obj.UserData.lastRange);
    set(obj, 'sigGenType', obj.UserData.sigGenType);
    set(obj, 'awgBufferSize', obj.UserData.awgBufferSize);
    set(obj, 'hasHardwareEts', obj.UserData.hasHardwareEts);
    set(obj, 'bufferMemory', obj.UserData.bufferMemory);
    set(obj, 'maxSamplingRate', obj.UserData.maxSamplingRate);
    
    % Inform the wrapper dll of the number of channels on the device
    calllib('ps5000aWrap', 'setChannelCount', get(obj, 'unitHandle'), ...
        get(obj, 'channelCount'));

    % Set the max. ADC value
    
    max_val_ptr = 0;

    [max_value_status, obj.UserData.maxADCValue]  = calllib('ps5000a', ...
        'ps5000aMaximumValue', get(obj, 'unitHandle'), max_val_ptr);
    
    set(obj, 'maxADCValue', obj.UserData.maxADCValue);
    
    clear max_val_ptr;
    clear max_value_status;
    
    % Set the min. ADC value 
    
    min_val_ptr = 0;

    [min_value_status, obj.UserData.minADCValue]  = calllib('ps5000a', ...
        'ps5000aMinimumValue', get(obj, 'unitHandle'), min_val_ptr);
       
    set(obj, 'minADCValue', obj.UserData.minADCValue);
    
    clear min_val_ptr;
    clear min_value_status;
    
    % Reset Channels
    [ch_a, ch_b, ch_c, ch_d, d0, d1] = invoke(obj, 'setChannelDefaults');

    % Turn off ETS
    
    disp('Turning off Equivalent Time Sampling...');
    
    [ets_status, st_ps] = invoke(obj, 'ps5000aSetEts', evalin('base', ...
                            'ps5000aEnuminfo.enPS5000AEtsMode.PS5000A_ETS_OFF'), 0, 0);

    % Turn off trigger

    fprintf('Turning off trigger...\n\n');
    trigger_status = invoke(obj, 'setTriggerOff');

    fprintf('Default Block mode parameters:-\n\n');
    
    % Set the default number of pre-trigger and post-trigger samples
    obj.UserData.numPreTriggerSamples = 0;
    set(obj, 'numPreTriggerSamples', obj.UserData.numPreTriggerSamples);
    
    obj.UserData.numPostTriggerSamples = 1024;
    set(obj, 'numPostTriggerSamples', obj.UserData.numPostTriggerSamples);
    
    total_samples = obj.UserData.numPreTriggerSamples + obj.UserData.numPostTriggerSamples;
    
    % Set the timebase - close to 1us for 524XA/B, 
    % and 500ns for 544XA/B
    obj.UserData.timebase = 65;
    set(obj, 'timebase', obj.UserData.timebase);
    
    time_interval_ns = 0;
    segment_index = 0;
    
    % Call get timebase to return interval in ns 
    [timebase_status, interval_ns, max_block_samples] = ...
        invoke(obj, 'ps5000aGetTimebase', obj.UserData.timebase, ...
        total_samples, time_interval_ns, segment_index);

    fprintf('               Timebase index : %d\n', obj.UserData.timebase);
    fprintf('                 Time Interval: %d ns\n', interval_ns);
    fprintf(' Number of pre-trigger samples: %d\n', obj.UserData.numPreTriggerSamples);
    fprintf('Number of post-trigger samples: %d\n', obj.UserData.numPostTriggerSamples);
    fprintf('       Total number of samples: %d\n', total_samples);
    
    fprintf('\n');
    
    fprintf('Default Streaming mode parameters:-\n\n');
    
    obj.UserData.streamingInterval = 1e-6; % 1us -&gt; 1MS/s
    obj.UserData.autoStop = PicoConstants.TRUE;
    
    set(obj, 'streamingInterval', obj.UserData.streamingInterval);
    set(obj, 'autoStop', obj.UserData.autoStop);
    
    fprintf(' Streaming interval: %d s\n', obj.UserData.streamingInterval);
    fprintf('Streaming auto stop: %d\n', obj.UserData.autoStop);
    
    fprintf('\n');
    
    if(obj.UserData.sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN || ...
            obj.UserData.sigGenType == PicoConstants.SIG_GEN_AWG)
       
        fprintf('Default Signal generator parameters:-\n\n');
        
        obj.UserData.startFrequency = 1000;
        set(obj, 'startFrequency', obj.UserData.startFrequency);
        
        obj.UserData.stopFrequency = 1000;
        set(obj, 'stopFrequency', obj.UserData.stopFrequency);
        
        fprintf('Start frequency: %d Hz\n', obj.UserData.startFrequency);
        fprintf(' Stop frequency: %d Hz\n', obj.UserData.stopFrequency);
        
    end
    
    fprintf('\n');
    disp('Initialisation complete.');</MCode>
               </Code>
               <Description>resetDevice(obj) sets the default parameters for the device.

This includes the folliowing:

1. Device specific properties.
2. Enabling all available channels to 5V range, DC coupled with 0 analogue offset.
3. Turning off the trigger and ETS mode.
4. Block mode parameters:

	Timebase index - 65, corresponding to a sampling interval of 504ns or ~1us depending on the device.
	numPreTriggerSamples - 0
 	numPostTriggerSamples - 1024

5. Streaming mode parameters:

	streamingInterval - 1e-6 (seconds)
	autoStop - 1
    
6. Signal Generator parameters:
        
	startFrequency = 1000 (Hz)
	stopFrequency = 1000 (Hz)

</Description>
            </Method>
            <Method>
               <Name>runBlock</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIndisposedMs] = runBlock(obj, segmentIndex)

    timeIndisposedMs = 0;   % Initialise to pass as pointer.
    lpReady = [];           % Set to NULL - Callback function not used.
    pParameter = [];        % Set to NULL - Callback function not used.
    
    timebase_index = get(obj, 'timebase');
    pre_trigger_samples = get(obj, 'numPreTriggerSamples');
    post_trigger_samples = get(obj, 'numPostTriggerSamples');
    
    fprintf('runBlock:- Collecting block of data:\n\tTimebase: %u\n\tPre-trigger samples: %u\n\tPost-trigger samples: %u\n', ...
        timebase_index, pre_trigger_samples, post_trigger_samples);

    [run_block_status, timeIndisposedMs] = calllib('ps5000a', 'ps5000aRunBlock', ...
        get(obj, 'unitHandle'), pre_trigger_samples, post_trigger_samples, ...
        timebase_index, segmentIndex, timeIndisposedMs, lpReady, pParameter);
    
    if(run_block_status ~= PicoStatus.PICO_OK)
           
        error('runBlock: Error in ps5000aRunBlock call - code %d', run_block_status); 
        
    end
    
    fprintf('runBlock: Waiting for device to become ready...\n');
    
    ready = 0; % Initialise value for pointer
    
    while(ready == 0)
        
        [ready_status, ready] = calllib('ps5000a', 'ps5000aIsReady', ...
                            get(obj, 'unitHandle'), ready);
                        
        if(ready_status ~= PicoStatus.PICO_OK)
           
            error('runBlock: Error in ps5000aIsReady call - code %d', ready_status); 
        
        end
                        
    end
    
    fprintf('runBlock: Device ready.\n\n');
    
    % Other conditions would have been captured.
    if(run_block_status == PicoStatus.PICO_OK &amp;&amp; ready_status == PicoStatus.PICO_OK)
        
        status = PicoStatus.PICO_OK;
        
    else
        
        if(run_block_status ~= PicoStatus.PICO_OK)
            
            error('runBlock:- ps5000aRunBlock error code: %d\n', run_block_status);
            
        else
            
            error('runBlock:- ps5000aIsReady error code: %d\n', ready_status);
                
        end
            
        
    end;
    
    
    </MCode>
               </Code>
               <Description>runBlock(obj, segmentIndex) starts collecting data in block mode and returns when the device is ready for data to be collected.

Input parameters:

obj - the object representing the device.
segmentIndex - zero-based index, specifying which memory segment to use.

Output parameters:

status - 0 if the ps5000aRunBlock and ps5000aIsReady functions have been executed correctly. 

For further information on the  ps5000aRunBlock and ps5000aIsReady functions please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.



</Description>
            </Method>
            <Method>
               <Name>setAdvancedTrigger</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function advTrigStatus = setAdvancedTrigger(obj, channelProperties, triggerConditions, directions, delay, autoTriggerMs)

    fprintf('setAdvancedTrigger: Number of channelProperties elements: %d\n', length(channelProperties));

    %disp('Trigger Channel Properties...')
    % Set the trigger channel properties
    % No aux output so set to 0
    advTrigStatus.set_trig_ch_prop_status = calllib('ps5000a', ...
        'ps5000aSetTriggerChannelProperties', get(obj, 'unitHandle'), ...
        channelProperties, length(channelProperties), 0, autoTriggerMs);

    advTrigStatus.set_trig_ch_prop_status;

    fprintf('setAdvancedTrigger: Number of triggerConditions elements: %d\n', length(triggerConditions));
    
    %disp('Trigger Channel Conditions...')
    % Set trigger conditions
    advTrigStatus.set_trig_ch_conditions_status = calllib('ps5000a', ...
        'ps5000aSetTriggerChannelConditions', get(obj, 'unitHandle'), ...
        triggerConditions, length(triggerConditions));

    advTrigStatus.set_trig_ch_conditions_status;

    %disp('Directions...')
    % Set directions
    advTrigStatus.set_trig_ch_dirs_status = invoke(obj, 'ps5000aSetTriggerChannelDirections', ...
        directions.channelA, directions.channelB, directions.channelC, ...
        directions.channelD, directions.external);

    advTrigStatus.set_trig_ch_dirs_status;

    %disp('Trigger delay...')
    % Post trigger delay
    advTrigStatus.set_trig_delay_status = calllib('ps5000a', ...
        'ps5000aSetTriggerDelay', get(obj, 'unitHandle'), delay);

    advTrigStatus.set_trig_delay_status;</MCode>
               </Code>
               <Description>setAdvancedTrigger(obj, channelProperties, triggerConditions, directions, delay, autoTriggerMs) sets the Advanced Trigger properties for the oscilloscope.

</Description>
            </Method>
            <Method>
               <Name>setAppAndDriverBuffers</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setAppAndDriverBuffers(obj, channel, appBuffer, driverBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000aWrap', 'setAppAndDriverBuffers', ...
        get(obj, 'unitHandle'), channel, appBuffer, driverBuffer, bufferLength);
    
    if(status ~= 0)
       
        error('setAppAndDriverBuffers: unable to set buffers in wrapper dll');
        
    end</MCode>
               </Code>
               <Description>setAppAndDriverBuffers(obj, channel, appBuffer, driverBuffer, bufferLength) set the application and corresponding driver buffer in the wrapper dll.

This function is required to allow the driver to copy the data into the application buffer being used in MATLAB when acquiring data from the PicoScope in 
streaming mode without aggregation.

Input parameters:

obj - the object representing the device.
channel - the channel to which the buffer corresponds (an enumeration from the PS5000A_CHANNEL range).
appBuffer - a libpointer to a 1-D array representing the application buffer.
driverBuffer - the libpointer passed to the driver in the ps5000aSetDataBuffer function call.
bufferLength - the length of the arrays (must be equal)

Output parameters:

status - status code returned by the wrapper:

0, if successful; -1, otherwise</Description>
            </Method>
            <Method>
               <Name>setChannelDefaults</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [setChA, setChB, setChC, setChD, setD0, setD1] = setChannelDefaults(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    fprintf('Default Channel Setup:-\n');
    fprintf('-----------------------\n\n');

    ch_a = evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_A');
    ch_b = evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_B');

    % Assign values used repeatedly to local variable

    true = PicoConstants.TRUE;
    range_5V = evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_5V');
    analogue_offset = 0;

    % Set default values for output in case channels are not available on 
    % the device - PicoScope 5000 series does not have digital channels.
    setChC = [];
    setChD = [];
    setD0 = [];
    setD1 = [];
    
    % Matrix of values to represent channels (rows) x properties (cols)
    obj.UserData.channelSettings = zeros(PicoConstants.QUAD_SCOPE);

    % Set Channel A and B, updating internal settings
    % Parameters are channel index, enabled, dc coupling, range index and 
    % analogue offset

    % Update internal setting
    channel_settings(1).enabled = true;
    channel_settings(1).dc = true;
    channel_settings(1).range = range_5V;
    channel_settings(1).offset = analogue_offset;
    
    channel_settings(2).enabled = true;
    channel_settings(2).dc = true;
    channel_settings(2).range = range_5V;
    channel_settings(2).offset = analogue_offset;
    
    %disp('DEBUG: setChannelDefaults')
    
    % Create a num channels x fields array
    ch_settings = zeros(PicoConstants.QUAD_SCOPE);
    
    % Transpose the resulting array
    ch_a_info = cell2mat(struct2cell(channel_settings(1)))';
    ch_b_info = cell2mat(struct2cell(channel_settings(2)))';
    
    % Combine together
    ch_settings(1, :) = ch_a_info;
    ch_settings(2, :) = ch_b_info;
    
    %disp('DEBUG: setChannelDefaults - assign')
    obj.UserData.channelSettings = ch_settings;
    
    set(obj, 'channelSettings', obj.UserData.channelSettings);
    
    %b = get(obj, 'channelSettings')
    
    %info = obj.UserData
    
    %disp('DEBUG: setChannelDefaults: Set channel settings')
    
    setChA = invoke(obj, 'ps5000aSetChannel', ch_a, true, true, range_5V, analogue_offset);
    fprintf('Channel A:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalogue Offset: 0.0V\n\n');

    setChB = invoke(obj, 'ps5000aSetChannel', ch_b, true, true, range_5V, analogue_offset);
    fprintf('Channel B:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalogue Offset: 0.0V\n\n');

    % Debug
    %obj.UserData.channelSettings
    
    % If device is a 544XA/B enable channels C and D
    % Check power status
    power_status = invoke(obj, 'ps5000aCurrentPowerSource');
    
    if(obj.UserData.channelCount == PicoConstants.QUAD_SCOPE &amp;&amp; ...
            power_status == PicoStatus.PICO_POWER_SUPPLY_CONNECTED)
    
        ch_c = evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_C');
        ch_d = evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_D');
        
        % Update internal setting
        channel_settings(3).enabled = true;
        channel_settings(3).dc = true;
        channel_settings(3).range = range_5V;
        channel_settings(3).offset = analogue_offset;

        channel_settings(4).enabled = true;
        channel_settings(4).dc = true;
        channel_settings(4).range = range_5V;
        channel_settings(4).offset = analogue_offset;
        
        % Add to the channel settings array
        ch_c_info = cell2mat(struct2cell(channel_settings(3)))';
        ch_d_info = cell2mat(struct2cell(channel_settings(4)))';
        
        ch_settings(3, :) = ch_c_info;
        ch_settings(4, :) = ch_d_info;
    
        obj.UserData.channelSettings = ch_settings;
    
        set(obj, 'channelSettings', obj.UserData.channelSettings);

        setChC = invoke(obj, 'ps5000aSetChannel', ch_c, true, true, range_5V, analogue_offset);
        fprintf('Channel C:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalogue Offset: 0.0V\n\n');

        setChD = invoke(obj, 'ps5000aSetChannel', ch_d, true, true, range_5V, analogue_offset);
        fprintf('Channel D:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalogue Offset: 0.0V\n\n');
        
        clear ch_c;
        clear ch_d;
        clear ch_c_info;
        clear ch_d_info;
    end
    
    % Clear local variables
    clear ch_a;
    clear ch_b;
    clear true;
    clear range_5V;
        </MCode>
               </Code>
               <Description>setChannelDefaults(obj) sets the following default values for any Analogue and Digital channels found on the device:

Analogue Channel:

Enabled: True
Coupling: DC
Voltage Range: 5V

Digital:

Enabled: True
LogicLevel: 1.5V</Description>
            </Method>
            <Method>
               <Name>setMaxMinAppAndDriverBuffers</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setMaxMinAppAndDriverBuffers(obj, channel, appMaxBuffer, appMinBuffer, driverMaxBuffer, driverMinBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps5000aWrap', 'setMaxMinAppAndDriverBuffers', ...
        get(obj, 'unitHandle'), channel, appMaxBuffer, appMinBuffer, ...
        driverMaxBuffer, driverMinBuffer, bufferLength);
    
    if(status ~= 0)
       
        error('setAppAndDriverBuffers: unable to set buffers in wrapper dll');
        
    end</MCode>
               </Code>
               <Description>setAppAndDriverBuffers(obj, channel, appMaxBuffer, appMinBuffer, driverMaxBuffer, driverMinBuffer, bufferLength) set the maximum and minimum application and corresponding driver buffers in the wrapper dll.

This function is required to allow the driver to copy the data into the maximum and minimum application buffers being used in MATLAB when acquiring data from the PicoScope in 
streaming mode with aggregation.

Input parameters:

obj - the object representing the device.
channel - the channel to which the buffer corresponds (an enumeration from the PS5000A_CHANNEL range).
appMaxBuffer - a libpointer to a 1-D array representing the application buffer.
appMinBuffer - a libpointer to a 1-D array representing the application buffer.
driverMaxBuffer - the libpointer passed to the driver for the maximum aggregated data values  in the ps5000aSetDataBuffers function call.
driverMinBuffer - the libpointer passed to the driver for the minimum aggregated data values in the ps5000aSetDataBuffers function call.
bufferLength - the length of the arrays (must be equal)

Output parameters:

status - status code returned by the wrapper:

0, if successful; -1, otherwise</Description>
            </Method>
            <Method>
               <Name>setPulseWidthQualifier</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setPulseWidthQualifier(obj, pwqConditions, direction, lower, upper, type)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    % Determine if the number of sub-elements in the array is correct.
    % Find the number of elements in the structure and use this with the
    % length of the conditions array.
    pwq_conditions_struct = evalin('base', 'ps5000aStructs.tPS5000APwqConditions.members');
    pwq_conditions_elements = length(fieldnames(pwq_conditions_struct));
    
    % Length of array containing PWQ elements
    pwq_length = length(pwqConditions)
    
    if(mod(pwq_length, pwq_conditions_elements) == 0)
        
        % Calculate the number of conditions
        num_conditions = pwq_length / pwq_conditions_elements;
        
        max_pwq_conditions = evalin('base'), 'PS5000aConstants.MAX_PULSE_WIDTH_QUALIFIER_COUNT');
        
        if(num_conditions &gt; 0 &amp;&amp; num_conditions &lt;= max_pwq_conditions)
        
            status = calllib('ps5000aWrap', 'SetPulseWidthQualifier', ...
                        get(obj, 'unitHandle'), properties, num_conditions, ...
                        direction, lower, upper, type);
                    
        else
           
            error('SetPulseWidthQualifier: Number of PWQ conditions must be between 0 and %d', max_pwq_conditions);
            
        end
        
    else
        
        error('SetPulseWidthQualifier: Incorrect number of sub-elements in pwq conditions array. The array must be 1xN with %d sub-elements', pwq_conditions_elements);
    
    end

    if(status ~= PicoStatus.PICO_OK)

        % TBD - Error handling 

    end
    
    clear pwq_conditions_struct;
    clear pwq_conditions_elements;
    clear pwq_length;
    clear num_conditions;
    clear max_pwq_conditions;</MCode>
               </Code>
               <Description>SetPulseWidthQualifier(obj, pwqConditions, direction, lower, upper, type) 

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
pwqConditions -  a 1-D array of n sub-arrays consisting of the elements in a PS5000A_PWQ_CONDITIONS structure.
direction - the direction of the signal required for the pulse width trigger to fire (a PS5000A_THRESHOLD_DIRECTION enumeration).
lower - the lower limit of the pulse-width counter with relation to number of samples captured on the device.
upper - the upper limit of the pulse-width counter with relation to number of samples captured on the device.
type - the pulse-width type (a PS5000A_PULSE_WIDTH_TYPE enumeration).

Output parameters:

status - status code returned by the device.

For further information on the SetPulseWidthQualifier function please refer to the ps5000aSetPulseWidthQualifer function in the  PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrary</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, dwell_time] = setSigGenArbitrary(obj, offsetVoltageMV, pkToPkMV, increment, dwellTime, arbitraryWaveform, sweepType, operation, indexMode, shots, sweeps, triggerType, triggerSource, extInThreshold)

    % Only call function if device has an Arbitrary Waveform Generator
    if(get(obj, 'sigGenType') == PicoConstants.SIG_GEN_AWG)

        offset_voltage = offsetVoltageMV * 1e3;
        pk_to_pk = pkToPkMV * 1e3;
        
        max_buffer_size = get(obj, 'awgBufferSize');
        dac_frequency = get(obj, 'dacFrequency');
        
        % Convert the waveform to the range for the driver
        arbitrary_waveform = int16(arbitraryWaveform * double(intmax('int16')));
        
        start_frequency = get(obj, 'startFrequency');

        start_delta_phase = freq2delta(start_frequency, length(arbitrary_waveform), ...
            max_buffer_size, dac_frequency);

        stop_delta_phase = 0;

        dwell_count = 0;


        % No need to calculate stop delta phase if start and stop frequencies
        % are the same.
        
        stop_frequency = get(obj, 'stopFrequency');
        
        if(stop_frequency == start_frequency)

            stop_delta_phase = start_delta_phase;

        else

            stop_delta_phase = freq2delta(stop_frequency, length(arbitrary_waveform), ...
                max_buffer_size, dac_frequency);

        end

        %fprintf('setSigGenArbitrary:Stop delta phase: %d\n', stop_delta_phase);
        
        delta_phase_increment = freq2delta(increment, length(arbitrary_waveform), ...
                max_buffer_size, dac_frequency);
            
        %fprintf('setSigGenArbitrary:Delta phase increment: %d\n', delta_phase_increment);

        dwell_count = round(dwellTime * dac_frequency); % Round to the nearest integer
        
        %fprintf('setSigGenArbitrary:Dwell count: %d\n', dwell_count);

        if(dwell_count &lt; PS5000aConstants.MIN_DWELL_COUNT)

            dwell_count = PS5000aConstants.MIN_DWELL_COUNT;

        end
        
        % Return dwell time information to the user if it has been
        % modified.
        dwell_time = dwell_count / dac_frequency;
        
        %fprintf('setSigGenArbitrary:Dwell time: %d\n', dwell_time);

        status = calllib('ps5000a', 'ps5000aSetSigGenArbitrary', ...
                    get(obj, 'unitHandle'), offset_voltage, pk_to_pk, start_delta_phase, ...
                    stop_delta_phase, delta_phase_increment, dwell_count, arbitrary_waveform, ...
                    length(arbitrary_waveform), sweepType, operation, indexMode, shots, ...
                    sweeps, triggerType, triggerSource, extInThreshold);
         
        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)
                    
            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenArbitrary: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenArbitrary: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenArbitrary: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenArbitrary: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenArbitrary: Unable to setup signal generator waveform.');
                    
                otherwise     
                    
                    error('setSigGenArbitrary: Status code: 0x%s. Please refer to the PS5000 Series (A API) Programmer''s Guide.\n', dec2hex(status));
            end
            
        end
        
        clear offset_voltage
        clear pk_to_pk
        clear max_buffer_size
        clear dac_frequency
        clear arbitrary_waveform
        clear start_delta_phase
        clear stop_delta_phase
        clear dwell_count
        clear delta_phase_increment
        clear start_frequency;
        clear stop_frequency;
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, offsetVoltageMV, pkToPkMV, increment, dwellTime, arbitraryWaveform, sweepType, operation, indexMode, shots, sweeps, triggerType, triggerSource, extInThreshold) programs the signal generator to produce an arbitrary waveform.

The startFrequency and stopFrequency properties must be set prior to calling this function.

The following parameters differ from the underlying ps5000aSetSigGenArbitrary function:

offsetVoltageMV - the offset voltage in millivolts 
pkToPkMV - the peak to peak value for the waveform in millivolts.
increment - the increase or decrease in frequency when operating in sweep mode.
dwellTime - the time for which the sweep stays at each frequency, in seconds.
arbitraryWaveform -  a buffer that holds the waveform pattern as a set of samples in the range -1 to +1. These values correspond to the maximum and minimum amplitude values of the waveform.

Note: the offsetVoltageMV and pkToPkMV parameters are converted to microvolts for the underlying driver function call.

The status code and calculated dwell time are returned by this function. The dwell time will be modified if the user specifies a dwell time corresponding to less than the minimum dwell count for the device (3).

For further information on the ps5000aSetSigGenArbitrary function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes.



 </Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrarySimple</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenArbitrarySimple(obj, offsetVoltageMV, pkToPkMV, arbitraryWaveform)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Only call function if device has an Arbitrary Waveform Generator
    if(get(obj, 'sigGenType') == PicoConstants.SIG_GEN_AWG)

        % Convert voltages to microvolts
        offset_voltage = offsetVoltageMV * 1e3;
        pk_to_pk = pkToPkMV * 1e3;
        
        max_buffer_size = get(obj, 'awgBufferSize');
        dac_frequency = get(obj, 'dacFrequency');
        
        % Convert the waveform to the range for the driver
        arbitrary_waveform = int16(arbitraryWaveform * double(intmax('int16')));

        start_delta_phase = freq2delta(get(obj, 'startFrequency'), length(arbitrary_waveform), ...
            max_buffer_size, dac_frequency);

        % Constant frequency
        stop_delta_phase = start_delta_phase;
        
        status = calllib('ps5000a', 'ps5000aSetSigGenArbitrary', ...
                    get(obj, 'unitHandle'), offset_voltage, pk_to_pk, start_delta_phase, ...
                    stop_delta_phase, 0, 0, arbitrary_waveform, ...
                    length(arbitraryWaveform), 0, 0, 0, 0, 0, 0, 0, 0);
         
        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)
                    
            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenArbitrary: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenArbitrary: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenArbitrary: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenArbitrary: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenArbitrary: Unable to setup signal generator waveform.');
                    
                otherwise     
                    
                    error('setSigGenArbitrary: Status code: 0x%s. Please refer to the PS5000 Series (A API) Programmer''s Guide.\n', dec2hex(status));
            end
            
        end
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end


</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, offsetVoltageMV, pkToPkMV, arbitraryWaveform) programs the signal generator to produce an arbitrary waveform at a constant frequency.

The startFrequency and stopFrequency properties must be set prior to calling this function.

The following parameters differ from the underlying ps3000aSetSigGenArbitrary function:

offsetVoltageMV - the offset voltage in millivolts 
pkToPkMV - the peak to peak value for the waveform in millivolts.
arbitraryWaveform -  a buffer that holds the waveform pattern as a set of samples in the range -1 to +1. These values correspond to the maximum and minimum amplitude values of the waveform.

Note: the offsetVoltageMV and pkToPkMV parameters are converted to microvolts for the underlying driver function call.

The status code and calculated dwell time are returned by this function. The dwell time will be modified if the user specifies a dwell time corresponding to less than the minimum dwell count for the device (3).

For further information on the ps5000aSetSigGenArbitrary function please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltIn</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltIn(obj, offsetVoltageMV, pkToPkMV, waveType, increment, dwellTime, sweepType, operation, shots, sweeps, triggerType, triggerSource, extInThresholdMV)

    sig_gen_type = get(obj, 'sigGenType');
    
    % Error checking
    if(sig_gen_type == PicoConstants.SIG_GEN_AWG || ...
            sig_gen_type == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert millivolt values to microvolts  
        offset_voltage = offsetVoltageMV * 1e3;
        pk_to_pk = pkToPkMV * 1e3;
        
        % Convert External trigger threshold to ADC Counts
        ext_in_threshold = mv2adc(extInThresholdMV, ...
            PS5000aConstants.PS5000A_EXT_MAX_VOLTAGE * 1e3, ...
            PS5000aConstants.PS5000A_EXT_MAX_VALUE);

        status = calllib('ps5000a', 'ps5000aSetSigGenBuiltIn', get(obj, 'unitHandle'), ...
                    offset_voltage, pk_to_pk, waveType, ...
                    get(obj, 'startFrequency'), get(obj, 'stopFrequency'), ...
                    increment, dwellTime, sweepType, operation, shots, sweeps, ...
                    triggerType, triggerSource, ext_in_threshold);

        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)

            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenBuiltIn: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenBuiltIn: Shots/sweeps warning.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenBuiltIn: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PICO_WARNING_EXT_THRESHOLD_CONFLICT

                    error('setSigGenBuiltIn: External threshold conflict.');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenBuiltIn: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenBuiltIn: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenBuiltIn: Unable to setup signal generator waveform.');

                otherwise     

                    error('setSigGenBuiltIn: Status code: 0x%s. Please refer to the PS5000 (A API) Programmer''s Guide.\n', dec2hex(status));
            end

        end
        
        clear offset_voltage;
        clear pk_to_pk;
        clear sig_gen_type;
            
    else
        
        error('setSigGenBuiltIn: Signal Generator functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenBuiltIn(obj, offsetVoltageMV, pkToPkMV, waveType, increment, dwellTime, sweepType, operation, shots, sweeps, triggerType, triggerSource, extInThresholdMV) sets up the signal generator to produce a signal from a list of built-in waveforms.

The startFrequency and stopFrequency properties must be set prior to calling this function.

The offset voltage (offsetVoltageMV), and peak to peak voltage (pkToPkMV) parameters are defined in millivolts and converted to microvolts for the underlying driver. The sum of offsetVoltageMV and pkToPkMV cannot exceed 4000 millivolts.

Use the following waveType enumerations:

A &amp; B Variants:

0 - SINE
1 - SQUARE
2 - TRIANGLE
8 - DC VOLTAGE

B Variants only:

3 - RAMP UP
4 - RAMP DOWN
5 - SINC
6 - GAUSSIAN
7 - HALF SINE

The extInThresholdMV value (if using the external trigger) is defined in millivolts.

For further information on the ps5000aSetSigGenBuiltIn function please refer to the PicoScope 5000 Series (A API) PC OscilloscopesProgrammer's Guide.

</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltInSimple</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltInSimple(obj, offsetVoltageMV, pkToPkMV, waveType)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
 
    sig_gen_type = get(obj, 'sigGenType');
    
    % Error checking
    if(sig_gen_type == PicoConstants.SIG_GEN_AWG || ...
            sig_gen_type == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert millivolt values to microvolts  
        offset_voltage = offsetVoltageMV * 1e3;
        pk_to_pk = pkToPkMV * 1e3;
        
        status = calllib('ps5000a', 'ps5000aSetSigGenBuiltIn', get(obj, 'unitHandle'), ...
                    offset_voltage, pk_to_pk, waveType, ...
                    get(obj, 'startFrequency'), get(obj, 'startFrequency'), ...
                        0, 0, 0, 0, 0, 0, 0, 0, 0);
                    
        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)

            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenBuiltInSimple: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenBuiltInSimple: Shots/sweeps warning.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenBuiltInSimple: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PICO_WARNING_EXT_THRESHOLD_CONFLICT

                    error('setSigGenBuiltInSimple: External threshold conflict.');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenBuiltInSimple: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenBuiltInSimple: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenBuiltInSimple: Unable to setup signal generator waveform.');

                otherwise     

                    error('setSigGenBuiltInSimple: Status code: 0x%s. Please refer to the PS5000 (A API) Programmer''s Guide.\n', dec2hex(status));
            end

        end  
        
        clear offset_voltage;
        clear pk_to_pk;
        clear sig_gen_type;
    
    else
        
        error('setSigGenBuiltInSimple: Signal Generator functionality not supported by this device.');
        
    end
    </MCode>
               </Code>
               <Description>setSigGenBuiltInSimple(obj, offsetVoltageMV, pkToPkMV, waveType) sets up the signal generator to produce a signal of constant frequency from a list of built-in waveforms.

The startFrequency property must be set prior to using this function.

The offset voltage (offsetVoltageMV) and peak to peak voltage (pkToPkMV) parameters are defined in millivolts and converted to microvolts for the underlying driver. The sum of offsetVoltageMV and pkToPkMV cannot exceed 4000 millivolts.

Use the following waveType enumerations:

A &amp; B Variants:

0 - SINE
1 - SQUARE
2 - TRIANGLE
8 - DC VOLTAGE

B Variants only:

3 - RAMP UP
4 - RAMP DOWN
5 - SINC
6 - GAUSSIAN
7 - HALF SINE</Description>
            </Method>
            <Method>
               <Name>setSigGenOff</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    offset_voltage = 0;
    pk_to_pk = 0;
    wave_type_dc = evalin('base', 'ps5000aEnuminfo.enPS5000AWaveType.PS5000A_DC_VOLTAGE');
    
    status = calllib('ps5000a', 'ps5000aSetSigGenBuiltIn', get(obj, 'unitHandle'), ...
                offset_voltage, pk_to_pk, wave_type_dc, 0, 0, ...
                0, 0, 0, 0, 0, 0, 0, 0, 0);
                    
	clear offset_voltage;
    clear pk_to_pk;
    clear wave_type_dc;</MCode>
               </Code>
               <Description>setSigGenOff(obj) effectively turns off the signal generator by setting the output to a zero DC voltage.</Description>
            </Method>
            <Method>
               <Name>setSimpleTrigger</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSimpleTrigger(obj, source, threshold_mv, direction, delay, autoTrigger_ms)

    % Find the voltage range index
    channel_range =  evalin('base', 'ps5000aEnuminfo.enPS5000ARange.PS5000A_5V');

    % Obtain information for device 
    channel_settings = cell2mat(obj.UserData.channelSettings(:));
    
    % Range is item 3 in the row for each channel

    switch(source)

        % Channel A
        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_A')

            channel_range = channel_settings(1,3);

        % Channel B
        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_B')

            channel_range = channel_settings(2,3);

        % Channel C
        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_C')

            channel_range = channel_settings(3,3);

        % Channel D
        case evalin('base', 'ps5000aEnuminfo.enPS5000AChannel.PS5000A_CHANNEL_D')

            channel_range = channel_settings(4,3);

        otherwise

            error('setSimpleTrigger: Invalid channel specified');

    end

    % Obtain the range being used in milliVolts
    channel_range_mv = PicoConstants.SCOPE_INPUT_RANGES(channel_range + 1);

    % Calculate the threshold in ADC counts
    threshold_adc = mv2adc(threshold_mv, channel_range_mv, get(obj, 'maxADCValue'));

    status = calllib('ps5000a', 'ps5000aSetSimpleTrigger', ...
            get(obj, 'unitHandle'), PicoConstants.TRUE, source, threshold_adc, direction, ...
            delay, autoTrigger_ms);</MCode>
               </Code>
               <Description>setSimpleTrigger(obj, source, threshold, direction, delay, autoTrigger_ms) simplifies arming the trigger. It supports only the LEVEL trigger types and does not allow more than one channel to have a trigger applied to it.</Description>
            </Method>
            <Method>
               <Name>setTriggerConditions</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setTriggerConditions(obj, conditions)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    % Determine if the number of sub-elements in the array is correct.
    % Find the number of elements in the structure and use this with the
    % length of the properties array.
    trig_conditions_struct = evalin('base', 'ps5000aStructs.tPS5000ATriggerChannelProperties.members');
    trig_conditions_elements = length(fieldnames(trig_conditions_struct));
    
    conditions_length = length(conditions);
    
    if(mod(conditions_length, trig_conditions_elements) == 0)
        
        % Calculate number of sub-elements in array.
        num_conditions = conditions_length / trig_properties_elements;
        
        status = calllib('ps5000aWrap', 'SetTriggerConditions', ...
        get(obj, 'unitHandle'), conditions, num_conditions);
        
    else
        
        error('SetTriggerConditions: Incorrect number of sub-elements in conditions array. The array must be 1xN with %d sub-elements', trig_conditions_elements);
    
    end
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>SetTriggerConditions(obj, conditions) sets up trigger conditions on the scope's inputs.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
conditions - a 1-D array of n sub-arrays consisting of the elements in a PS5000A_TRIGGER_CONDITIONS structure.

Output parameters:

status - status code returned by the device.

For further information on the SetTriggerConditions function please refer to the ps5000aSetTriggerChannelConditions function in the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setTriggerOff</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setTriggerOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Set trigger to false for channel A
    
    %source = 0; % Channel A
    %threshold_adc = 0;
    %direction = 0;
    %delay = 0;
    %autoTrigger_ms = 0;
    
    %status = calllib('ps5000a', 'ps5000aSetSimpleTrigger', ...
    %        get(obj, 'unitHandle'), PicoConstants.FALSE, source, ...
    %        threshold_adc, direction, delay, autoTrigger_ms);
    
    status = calllib('ps5000a', 'ps5000aSetTriggerChannelConditions', ...
        get(obj, 'unitHandle'), [], 0);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error();
        
    end</MCode>
               </Code>
               <Description>setTriggerOff(obj) switches off triggering on the oscilloscope.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the device.</Description>
            </Method>
            <Method>
               <Name>setTriggerProperties</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setTriggerProperties(obj, properties, autoTrig)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Determine if the number of sub-elements in the array is correct.
    % Find the number of elements in the structure and use this with the
    % length of the properties array.
    trig_properties_struct = evalin('base', 'ps5000aStructs.tPS5000ATriggerChannelProperties.members');
    trig_properties_elements = length(fieldnames(trig_properties_struct));
    
    properties_length = length(properties)
    
    if(mod(properties_length, trig_properties_elements) == 0)
        
        num_properties = properties_length / trig_properties_elements;
        
        status = calllib('ps5000aWrap', 'SetTriggerProperties', ...
        get(obj, 'unitHandle'), properties, num_properties, autoTrig);
        
    else
        
        error('SetTriggerProperties: Incorrect number of sub-elements in properties array. The array must be 1xN with %d sub-elements', trig_properties_elements);
    
    end
    
    if(status ~= PicoStatus.PICO_OK)
           
        % TBD - Error handling 
        
    end</MCode>
               </Code>
               <Description>SetTriggerProperties(obj, properties, nProperties, autoTrig) sets the trigger properties for the device.

This function may be used with the Test and Measurement Tool in place of the ps5000aSetTriggerChannelProperties function called in the SetAdvancedTrigger function.

Input parameters:

obj - the object representing the device.
properties - a 1-D array of n sub-arrays consisting of the elements in a PS5000A_TRIGGER_CHANNEL_PROPERTIES structure.
autoTrig - the time in milliseconds for which the scope device will wait before collecting data if no trigger event occurs.

Output parameters:

status - status code returned by the device.

For further information on the ps5000aSetTriggerChannelProperties function and the TRIGGER_CHANNEL_PROPERTIES structure please refer to the PicoScope 5000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>